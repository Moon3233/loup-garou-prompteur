<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prompteur - Ma√Ætre du Jeu - Loup-Garou</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Creepster', 'Arial Black', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: 
                radial-gradient(circle at 20% 50%, rgba(139, 0, 0, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(128, 0, 128, 0.3) 0%, transparent 50%),
                linear-gradient(135deg, #0a0a0a 0%, #1a0000 25%, #0a0a0a 50%, #1a001a 75%, #0a0a0a 100%);
            background-size: 100% 100%, 100% 100%, 400% 400%;
            background-position: 0% 0%, 100% 100%, 0% 0%;
            animation: backgroundShift 20s ease infinite;
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, rgba(255, 140, 0, 0.15), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(255, 69, 0, 0.15), transparent),
                radial-gradient(1px 1px at 50% 50%, rgba(255, 140, 0, 0.2), transparent),
                radial-gradient(1px 1px at 80% 10%, rgba(128, 0, 128, 0.15), transparent);
            background-size: 200% 200%, 300% 300%, 400% 400%, 250% 250%;
            animation: starfield 60s linear infinite;
            pointer-events: none;
            z-index: 0;
        }

        @keyframes backgroundShift {
            0%, 100% { background-position: 0% 0%, 100% 100%, 0% 0%; }
            50% { background-position: 100% 100%, 0% 0%, 100% 100%; }
        }

        @keyframes starfield {
            0% { transform: translate(0, 0); }
            100% { transform: translate(-50%, -50%); }
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            width: 100%;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 140, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.2), inset 0 0 20px rgba(139, 0, 0, 0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 
                0 0 10px rgba(255, 140, 0, 0.8),
                0 0 20px rgba(255, 140, 0, 0.6),
                0 0 30px rgba(255, 69, 0, 0.4),
                2px 2px 4px rgba(0, 0, 0, 0.8);
            color: #FF8C00;
            animation: glow 3s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 
                    0 0 10px rgba(255, 140, 0, 0.8),
                    0 0 20px rgba(255, 140, 0, 0.6),
                    0 0 30px rgba(255, 69, 0, 0.4),
                    2px 2px 4px rgba(0, 0, 0, 0.8);
            }
            to {
                text-shadow: 
                    0 0 15px rgba(255, 140, 0, 1),
                    0 0 25px rgba(255, 140, 0, 0.8),
                    0 0 35px rgba(255, 69, 0, 0.6),
                    0 0 45px rgba(128, 0, 128, 0.4),
                    2px 2px 4px rgba(0, 0, 0, 0.8);
            }
        }

        .phase-info {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-top: 10px;
            color: #FFB84D;
            text-shadow: 0 0 5px rgba(255, 140, 0, 0.5);
        }

        .prompteur {
            flex: 1;
            background: 
                radial-gradient(ellipse at center, rgba(255, 140, 0, 0.1) 0%, transparent 70%),
                linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(26, 0, 0, 0.95) 100%);
            color: #FFE4B5;
            border-radius: 20px;
            padding: 60px 40px;
            margin-bottom: 30px;
            box-shadow: 
                0 0 30px rgba(255, 140, 0, 0.3),
                0 0 60px rgba(139, 0, 0, 0.2),
                inset 0 0 40px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255, 140, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 400px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .prompteur::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 140, 0, 0.05) 0%, transparent 70%);
            animation: rotate 20s linear infinite;
            pointer-events: none;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .prompteur-content {
            width: 100%;
            max-width: 900px;
            position: relative;
            z-index: 1;
        }

        .prompteur-title {
            font-size: 3rem;
            font-weight: bold;
            margin-bottom: 30px;
            color: #FF8C00;
            line-height: 1.2;
            text-shadow: 
                0 0 10px rgba(255, 140, 0, 0.8),
                0 0 20px rgba(255, 140, 0, 0.6),
                2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .prompteur-text {
            font-size: 1.8rem;
            line-height: 1.6;
            color: #FFE4B5;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.3), 2px 2px 4px rgba(0, 0, 0, 0.8);
            min-height: 80px;
            max-height: 85vh;
            overflow: hidden;
            padding: 10px;
        }


        .prompteur-text ul {
            list-style: none;
            padding: 0;
            margin: 20px 0;
            text-align: left;
            display: inline-block;
            width: 100%;
            max-width: 900px;
        }

        .prompteur-text li {
            padding: 12px 20px;
            margin: 8px 0;
            border-radius: 10px;
            transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease, color 0.2s ease;
            border-left: 4px solid transparent;
            background: rgba(0, 0, 0, 0.2);
            font-size: 1.6rem;
            line-height: 1.5;
            contain: layout style paint;
        }

        .prompteur-text li.active-action {
            background: rgba(255, 140, 0, 0.3);
            border-left: 4px solid #FF8C00;
            box-shadow: 
                0 0 20px rgba(255, 140, 0, 0.4),
                inset 0 0 20px rgba(255, 140, 0, 0.1);
            /* Pas de transform scale pour √©viter les recalculs de layout */
            font-weight: 600;
            color: #FFE4B5;
            text-shadow: 0 0 15px rgba(255, 140, 0, 0.6), 2px 2px 4px rgba(0, 0, 0, 0.8);
            contain: layout style paint;
        }

        .prompteur-text li.completed-action {
            opacity: 0.6;
            color: #CCB895;
        }

        .prompteur-text > div {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border-left: 4px solid rgba(255, 140, 0, 0.5);
        }

        .phase-description {
            margin-bottom: 25px !important;
            padding: 20px 20px 20px 50px !important;
            background: linear-gradient(135deg, rgba(75, 0, 130, 0.3), rgba(25, 25, 112, 0.3)) !important;
            border-radius: 12px !important;
            border-left: 5px solid rgba(138, 43, 226, 0.8) !important;
            border-right: 2px solid rgba(138, 43, 226, 0.3) !important;
            box-shadow: 
                0 0 15px rgba(138, 43, 226, 0.4),
                inset 0 0 20px rgba(138, 43, 226, 0.1) !important;
            font-style: italic !important;
            color: #E0B0FF !important;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.5), 2px 2px 4px rgba(0, 0, 0, 0.8) !important;
            position: relative !important;
        }

        .typing-cursor {
            display: inline-block;
            width: 3px;
            height: 1.2em;
            background: #FF8C00;
            margin-left: 2px;
            animation: blink 1s infinite;
            vertical-align: baseline;
            box-shadow: 0 0 5px rgba(255, 140, 0, 0.8);
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .prompteur-list {
            font-size: 1.6rem;
            line-height: 2;
            text-align: left;
            display: inline-block;
            color: #2c3e50;
        }

        .prompteur-list li {
            margin-bottom: 15px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.1rem;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-primary {
            background: linear-gradient(135deg, #FF8C00 0%, #FF4500 100%);
            color: #0a0a0a;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 15px rgba(255, 140, 0, 0.3), inset 0 0 10px rgba(255, 200, 0, 0.2);
        }

        .btn-primary:hover {
            box-shadow: 0 6px 20px rgba(255, 140, 0, 0.5), inset 0 0 15px rgba(255, 200, 0, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #8B0000 0%, #FF4500 100%);
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(139, 0, 0, 0.3), inset 0 0 10px rgba(255, 140, 0, 0.1);
        }

        .btn-secondary:hover {
            box-shadow: 0 6px 20px rgba(139, 0, 0, 0.5), inset 0 0 15px rgba(255, 140, 0, 0.2);
        }

        .btn-sound {
            background: linear-gradient(135deg, #2F4F4F 0%, #1C1C1C 100%);
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(47, 79, 79, 0.3), inset 0 0 10px rgba(139, 0, 139, 0.1);
        }

        .btn-sound:hover {
            box-shadow: 0 6px 20px rgba(47, 79, 79, 0.5), inset 0 0 15px rgba(139, 0, 139, 0.2);
            transform: translateY(-2px);
        }

        .btn-sound:active {
            transform: translateY(0);
        }

        .btn-danger {
            background: linear-gradient(135deg, #800080 0%, #4B0082 100%);
            color: #FFE4B5;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(128, 0, 128, 0.3), inset 0 0 10px rgba(139, 0, 139, 0.2);
        }

        .btn-danger:hover {
            box-shadow: 0 6px 20px rgba(128, 0, 128, 0.5), inset 0 0 15px rgba(139, 0, 139, 0.3);
        }

        .btn-success {
            background: linear-gradient(135deg, #FF8C00 0%, #FFD700 100%);
            color: #0a0a0a;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3), inset 0 0 10px rgba(255, 255, 0, 0.2);
        }

        .navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 12px 30px;
            font-size: 1rem;
            background: rgba(0, 0, 0, 0.6);
            color: #FFB84D;
            border: 2px solid rgba(255, 140, 0, 0.4);
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(255, 140, 0, 0.5);
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.2);
        }

        .nav-btn:hover:not(:disabled) {
            background: rgba(255, 140, 0, 0.2);
            border-color: rgba(255, 140, 0, 0.6);
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.4);
            transform: translateY(-2px);
        }

        .nav-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: rgba(255, 140, 0, 0.2);
        }

        .phase-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .phase-btn {
            padding: 10px 20px;
            font-size: 0.9rem;
            background: rgba(0, 0, 0, 0.5);
            color: #FFB84D;
            border: 1px solid rgba(255, 140, 0, 0.3);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-shadow: 0 0 3px rgba(255, 140, 0, 0.3);
        }

        .phase-btn:hover {
            background: rgba(255, 140, 0, 0.15);
            border-color: rgba(255, 140, 0, 0.5);
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.3);
        }

        .phase-btn.active {
            background: rgba(255, 140, 0, 0.3);
            border-color: rgba(255, 140, 0, 0.7);
            font-weight: bold;
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.5);
            color: #FFE4B5;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
                max-width: 100%;
            }

            .header {
                padding: 15px;
                margin-bottom: 15px;
            }

            .header h1 {
                font-size: 1.8rem;
                margin-bottom: 8px;
            }

            .phase-info {
                font-size: 0.9rem;
            }

            .prompteur {
                padding: 20px 15px;
                margin-bottom: 15px;
                min-height: 300px;
                border-radius: 15px;
            }

            .prompteur-title {
                font-size: 1.5rem;
                margin-bottom: 15px;
            }

            .prompteur-text {
                font-size: 1.1rem;
                line-height: 1.4;
                padding: 8px;
                max-height: 75vh;
            }

            .phase-description {
                font-size: 1rem !important;
                padding: 15px 15px 15px 40px !important;
                margin-bottom: 15px !important;
            }

            .prompteur-text li {
                font-size: 1rem !important;
                padding: 12px 15px !important;
                margin: 8px 0 !important;
            }

            .prompteur-list {
                font-size: 1.1rem;
            }

            .btn-primary, .btn-secondary, .btn-danger, .btn-success, .btn-sound {
                padding: 10px 15px;
                font-size: 0.9rem;
                margin: 5px;
            }

            .nav-buttons {
                flex-direction: column;
                gap: 10px;
            }

            .nav-buttons .btn-primary,
            .nav-buttons .btn-secondary {
                width: 100%;
            }

            .navigation {
                flex-direction: column;
                gap: 10px;
            }

            .nav-btn {
                padding: 12px 20px;
                font-size: 0.9rem;
                width: 100%;
            }

            .controls {
                gap: 10px;
            }

            .btn {
                padding: 12px 25px;
                font-size: 0.95rem;
            }

            .phase-selector {
                flex-wrap: wrap;
                gap: 8px;
                justify-content: center;
            }

            .phase-btn {
                padding: 8px 12px;
                font-size: 0.85rem;
                min-width: auto;
                flex: 1 1 auto;
                max-width: calc(50% - 4px);
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Bouton burger menu */
        .burger-menu-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 3001;
            width: 50px;
            height: 50px;
            background: rgba(255, 140, 0, 0.2);
            border: 2px solid rgba(255, 140, 0, 0.5);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 6px;
            padding: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(255, 140, 0, 0.3);
        }

        .burger-menu-btn:hover {
            background: rgba(255, 140, 0, 0.3);
            box-shadow: 0 0 20px rgba(255, 140, 0, 0.5);
        }

        .burger-menu-btn span {
            display: block;
            width: 25px;
            height: 3px;
            background: #FF8C00;
            border-radius: 3px;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(255, 140, 0, 0.5);
        }

        .burger-menu-btn.active span:nth-child(1) {
            transform: rotate(45deg) translate(8px, 8px);
        }

        .burger-menu-btn.active span:nth-child(2) {
            opacity: 0;
        }

        .burger-menu-btn.active span:nth-child(3) {
            transform: rotate(-45deg) translate(7px, -7px);
        }


        /* Page d'aide aux r√¥les */
        body.help-mode {
            background: #fad69e;
            overflow: hidden;
        }

        .help-page {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            background: #fad69e;
            z-index: 1500;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }

        .help-header {
            max-width: 1400px;
            margin: 0 auto 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            position: relative;
        }


        .help-header h1 {
            color: #333;
            font-size: 2.5rem;
            margin: 0;
        }

        .help-content {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Overlay pour fermer le menu */
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 3099;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(2px);
            pointer-events: none;
        }

        .menu-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        /* Styles pour la s√©lection des r√¥les */
        .role-selector-panel {
            position: fixed;
            top: 0;
            left: -400px;
            width: 380px;
            height: 100vh;
            background: rgba(0, 0, 0, 0.95);
            border-right: 3px solid rgba(255, 140, 0, 0.5);
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(255, 140, 0, 0.3);
            overflow-y: auto;
            z-index: 3100;
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .role-selector-panel.active {
            left: 0;
        }

        .role-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(255, 140, 0, 0.3);
            flex-wrap: wrap;
            gap: 10px;
        }


        .menu-header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .role-help-btn {
            padding: 8px 15px;
            background: rgba(37, 150, 190, 0.2);
            border: 1px solid rgba(37, 150, 190, 0.5);
            border-radius: 8px;
            color: #2596be;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            font-weight: bold;
        }

        .role-help-btn:hover {
            background: rgba(37, 150, 190, 0.3);
            border-color: rgba(37, 150, 190, 0.7);
        }

        .role-back-btn {
            padding: 8px 15px;
            background: rgba(255, 140, 0, 0.2);
            border: 1px solid rgba(255, 140, 0, 0.5);
            border-radius: 8px;
            color: #FF8C00;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: inherit;
            font-weight: bold;
        }

        .role-back-btn:hover {
            background: rgba(255, 140, 0, 0.3);
            border-color: rgba(255, 140, 0, 0.7);
        }

        .role-close-btn {
            width: 35px;
            height: 35px;
            background: rgba(255, 140, 0, 0.2);
            border: 2px solid rgba(255, 140, 0, 0.5);
            border-radius: 50%;
            color: #FF8C00;
            font-size: 1.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            line-height: 1;
        }

        .role-close-btn:hover {
            background: rgba(255, 140, 0, 0.3);
            transform: rotate(90deg);
        }


        .role-selector-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .elimination-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 140, 0, 0.3);
        }

        .elimination-section h3 {
            font-size: 1.1rem;
            color: #FF8C00;
            margin-bottom: 15px;
            text-align: center;
        }

        #eliminationList {
            max-height: 200px;
            overflow-y: auto;
        }

        .names-management-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 140, 0, 0.3);
        }

        .names-management-section h3 {
            font-size: 1.1rem;
            color: #FF8C00;
            margin-bottom: 15px;
            text-align: center;
        }

        #namesManagementList {
            max-height: 200px;
            overflow-y: auto;
        }

        .role-selection-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 140, 0, 0.3);
        }

        .role-selection-section h3 {
            font-size: 1.1rem;
            color: #FF8C00;
            margin-bottom: 15px;
            text-align: center;
        }

        .role-selection-section .role-categories {
            max-height: 400px;
            overflow-y: auto;
        }

        #eliminationList::-webkit-scrollbar {
            width: 6px;
        }

        #eliminationList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        #eliminationList::-webkit-scrollbar-thumb {
            background: rgba(255, 140, 0, 0.4);
            border-radius: 10px;
        }

        #eliminationList::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 140, 0, 0.7);
        }

        #namesManagementList::-webkit-scrollbar {
            width: 6px;
        }

        #namesManagementList::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        #namesManagementList::-webkit-scrollbar-thumb {
            background: rgba(255, 140, 0, 0.4);
            border-radius: 10px;
        }

        #namesManagementList::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 140, 0, 0.7);
        }

        .role-selection-section .role-categories::-webkit-scrollbar {
            width: 6px;
        }

        .role-selection-section .role-categories::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .role-selection-section .role-categories::-webkit-scrollbar-thumb {
            background: rgba(255, 140, 0, 0.4);
            border-radius: 10px;
        }

        .role-selection-section .role-categories::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 140, 0, 0.7);
        }

        /* Styles pour l'aide aux r√¥les */
        .role-help-content {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 10px;
        }

        .role-help-card {
            background: transparent;
            border: none;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: all 0.3s ease;
        }

        .role-help-card:hover {
            transform: translateY(-5px);
        }

        .role-image-container {
            position: relative;
            margin-bottom: 20px;
        }

        .role-help-card-image {
            width: 180px;
            height: 252px;
            object-fit: contain;
            border-radius: 10px;
            background: transparent;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .role-image-container:hover .role-help-card-image {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(37, 150, 190, 0.5);
        }

        .role-help-card-title {
            font-size: 1.5rem;
            color: #333;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }

        .role-help-card-description {
            font-size: 1rem;
            color: #333;
            line-height: 1.7;
            text-align: justify;
            flex: 1;
        }

        .role-selector-title {
            font-size: 1.3rem;
            color: #FF8C00;
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
        }

        .role-toggle-btn {
            padding: 8px 15px;
            font-size: 0.9rem;
            background: rgba(255, 140, 0, 0.2);
            color: #FFE4B5;
            border: 1px solid rgba(255, 140, 0, 0.5);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .role-toggle-btn:hover {
            background: rgba(255, 140, 0, 0.3);
            box-shadow: 0 0 10px rgba(255, 140, 0, 0.4);
        }

        .role-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .role-category {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 140, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
        }

        .role-category-title {
            font-size: 1.1rem;
            color: #FFB84D;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 140, 0, 0.3);
            text-shadow: 0 0 5px rgba(255, 140, 0, 0.3);
        }

        .role-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .role-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            border-radius: 5px;
            transition: all 0.2s ease;
        }

        .role-item:hover {
            background: rgba(255, 140, 0, 0.1);
        }

        .role-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #FF8C00;
        }

        .role-item label {
            flex: 1;
            cursor: pointer;
            color: #FFE4B5;
            font-size: 0.95rem;
            user-select: none;
        }

        .role-item.active label {
            color: #FFB84D;
            font-weight: bold;
        }

        .role-selector-panel .role-selection-section .role-categories {
            flex: 1;
        }

        @media (max-width: 768px) {
            .role-categories {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .role-selector-panel {
                width: 90%;
                max-width: 380px;
                padding: 15px;
            }

            .role-selector-header {
                flex-direction: row;
                align-items: center;
            }

            .role-selector-title {
                font-size: 1.1rem;
            }

            .role-toggle-btn {
                padding: 10px;
                font-size: 0.85rem;
                flex: 1;
                text-align: center;
            }

            .role-selector-controls {
                flex-direction: column;
            }

            .burger-menu-btn {
                width: 45px;
                height: 45px;
                top: 15px;
                left: 15px;
            }

            .role-category {
                padding: 12px;
            }

            .role-category-title {
                font-size: 1rem;
            }

            .role-item label {
                font-size: 0.9rem;
            }

            .role-item input[type="checkbox"] {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 8px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .phase-info {
                font-size: 0.8rem;
            }

            .prompteur-title {
                font-size: 1.3rem;
            }

            .prompteur {
                padding: 15px 10px;
                min-height: 250px;
            }

            .prompteur-text {
                font-size: 1rem;
                max-height: 70vh;
            }

            .phase-description {
                font-size: 0.95rem !important;
                padding: 12px 12px 12px 35px !important;
            }

            .prompteur-text li {
                font-size: 0.95rem !important;
                padding: 10px 12px !important;
            }

            .btn-primary, .btn-secondary, .btn-danger, .btn-success, .btn-sound {
                padding: 10px 15px;
                font-size: 0.85rem;
            }

            .nav-btn {
                padding: 10px 15px;
                font-size: 0.85rem;
            }

            .phase-btn {
                font-size: 0.75rem;
                padding: 6px 10px;
            }

            .controls {
                gap: 8px;
            }

            .btn {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .role-selector-panel {
                padding: 12px;
            }

            .role-selector-title {
                font-size: 1rem;
            }

            .role-category-title {
                font-size: 0.95rem;
            }

            .role-item label {
                font-size: 0.85rem;
            }

            .role-help-content {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .role-help-card-image {
                width: 150px;
                height: 210px;
            }

            .role-help-card-title {
                font-size: 1.3rem;
            }

            .role-help-card-description {
                font-size: 0.95rem;
            }

            .help-header h1 {
                font-size: 1.8rem;
            }

            .help-header {
                flex-direction: column;
                align-items: stretch;
            }


            .menu-header-actions {
                flex-direction: column;
                width: 100%;
            }

            .role-help-btn {
                width: 100%;
                text-align: center;
            }

            .role-selector-header {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Overlay pour fermer le menu -->
    <div class="menu-overlay" id="menuOverlay" onclick="toggleBurgerMenu()"></div>

    <!-- Menu burger pour la s√©lection des r√¥les -->
    <div class="role-selector-panel" id="roleSelectorPanel">
        <div class="role-selector-header">
            <h2 class="role-selector-title">üé≠ S√©lection des R√¥les</h2>
            <div class="menu-header-actions">
                <button class="role-help-btn" id="roleHelpBtnInMenu" onclick="showHelpPage(); toggleBurgerMenu();">üìñ Aide aux R√¥les</button>
                <button class="role-back-btn" id="rolePrompteurBtnInMenu" onclick="hideHelpPage(); toggleBurgerMenu();">üéÆ Prompteur</button>
                <button class="role-close-btn" onclick="toggleBurgerMenu()">‚úï</button>
            </div>
        </div>
        
        <div class="role-selector-controls">
            <button class="role-toggle-btn" onclick="toggleAllRoles(true)">Tout s√©lectionner</button>
            <button class="role-toggle-btn" onclick="toggleAllRoles(false)">Tout d√©s√©lectionner</button>
            <button class="role-toggle-btn" onclick="reloadWithMenuOpen()" style="background: rgba(100, 150, 255, 0.2); border-color: rgba(100, 150, 255, 0.5); width: 100%;">üîÑ Recharger la page</button>
            <div style="position: relative; width: 100%;">
                <button class="role-toggle-btn" id="resetRoleNamesBtn" onclick="showResetConfirmation()" style="background: rgba(255, 100, 100, 0.2); border-color: rgba(255, 100, 100, 0.5); width: 100%;">üóëÔ∏è R√©initialiser les pr√©noms</button>
                <div id="resetConfirmation" style="display: none; margin-top: 10px; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 5px; text-align: center;">
                    <p style="color: #FFE4B5; font-size: 0.9rem; margin-bottom: 10px;">√ätes-vous s√ªr ?</p>
                    <div style="display: flex; gap: 10px; justify-content: center;">
                        <button id="confirmResetBtn" style="padding: 5px 15px; background: rgba(100, 255, 100, 0.3); color: #FFE4B5; border: 1px solid rgba(100, 255, 100, 0.5); border-radius: 5px; cursor: pointer; font-size: 1.2rem;">‚úì</button>
                        <button id="cancelResetBtn" style="padding: 5px 15px; background: rgba(255, 100, 100, 0.3); color: #FFE4B5; border: 1px solid rgba(255, 100, 100, 0.5); border-radius: 5px; cursor: pointer; font-size: 1.2rem;">‚úï</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="elimination-section">
            <h3>‚ö∞Ô∏è √âliminations</h3>
            <div id="eliminationList"></div>
        </div>
        <div class="names-management-section">
            <h3>üë• Gestion des Pr√©noms</h3>
            <div id="namesManagementList"></div>
        </div>
        <div class="role-selection-section">
            <h3>üé≠ S√©lection des R√¥les</h3>
            <div class="role-categories" id="roleCategories"></div>
        </div>
    </div>

    <div class="container">
        <div class="header">
            <button class="burger-menu-btn" id="burgerMenuBtn" onclick="toggleBurgerMenu()">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <h1>üéÉ Loup-Garou ü¶á</h1>
            <div class="phase-info" id="phaseInfo">Pr√™t √† commencer</div>
        </div>

        <div class="prompteur fade-in" id="prompteur">
            <div class="prompteur-content">
                <div class="prompteur-title" id="prompteurTitle">Bienvenue Ma√Ætre du Jeu</div>
                <div class="prompteur-text" id="prompteurText">
                    Cliquez sur "Commencer la partie" pour d√©marrer la premi√®re phase du jeu.
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" id="startBtn">Commencer la partie</button>
            <button class="btn btn-secondary" id="nextBtn" style="display: none;">Phase suivante</button>
            <button class="btn btn-sound" id="wolfHowlBtn" onclick="playWolfHowl()" style="display: none;">üê∫ Hurlement</button>
        </div>
        
        <!-- √âl√©ment audio pour le hurlement du loup -->
        <audio id="wolfHowlAudio" preload="auto">
            <source src="wolf-howl.mp3" type="audio/mpeg">
        </audio>

        <div class="navigation">
            <div class="phase-selector" id="phaseSelector"></div>
        </div>
    </div>

    <!-- Page d'aide aux r√¥les -->
    <div class="help-page" id="helpPage" style="display: none;">
        <div class="help-header">
            <button class="burger-menu-btn" id="helpBurgerMenuBtn" onclick="toggleBurgerMenu()">
                <span></span>
                <span></span>
                <span></span>
            </button>
            <h1>üìñ Aide aux R√¥les - Loup-Garou</h1>
        </div>
        <div class="help-content" id="helpPageContent"></div>
    </div>

    <script>
        // Structure compl√®te de tous les r√¥les disponibles
        const allRoles = {
            base: [
            {
                id: 'voyante',
                    name: 'Voyante',
                    icon: 'üîÆ',
                    category: 'base',
                    phase: 'nuit',
                    order: 1,
                    firstNight: true,
                    everyNight: true,
                    text: 'La voyante se r√©veille chaque nuit (y compris la premi√®re) et d√©couvre l\'identit√© d\'un joueur de son choix.',
                actions: [
                    'La voyante se r√©veille',
                    'Elle pointe vers un joueur',
                    'Vous lui montrez sa carte',
                    'La voyante se rendort'
                ]
            },
            {
                id: 'cupidon',
                    name: 'Cupidon',
                    icon: 'üíò',
                    category: 'base',
                    phase: 'nuit',
                    order: 0,
                    firstNight: true,
                text: 'Cupidon d√©signe deux amoureux. Si l\'un meurt, l\'autre se suicide.',
                actions: [
                    'Cupidon se r√©veille',
                    'Il d√©signe deux amoureux',
                    'Vous r√©veillez les deux amoureux',
                    'Ils se reconnaissent puis se rendorment',
                    'Cupidon se rendort'
                ]
            },
            {
                id: 'loups',
                    name: 'Loup-Garou',
                    icon: 'üê∫',
                    category: 'base',
                    phase: 'nuit',
                    order: 3,
                    firstNight: true,
                    everyNight: true,
                text: 'Les loups-garous se r√©veillent et se reconnaissent. Ils d√©signent une victime.',
                actions: [
                    'Les loups-garous se r√©veillent',
                    'Ils se reconnaissent',
                        'Si la Petite Fille est en jeu : elle peut entrouvrir les yeux pour espionner',
                        'Attention : si un loup voit la Petite Fille, elle peut √™tre d√©vor√©e imm√©diatement',
                        'Les loups d√©signent silencieusement une victime',
                    'Vous notez leur choix',
                    'Les loups-garous se rendorment'
                ]
            },
            {
                id: 'sorciere',
                    name: 'Sorci√®re',
                    icon: 'üß™',
                    category: 'base',
                    phase: 'nuit',
                    order: 4,
                    firstNight: true,
                    everyNight: true,
                    text: 'La sorci√®re se r√©veille chaque nuit (y compris la premi√®re). Elle peut sauver la victime des loups ou empoisonner quelqu\'un. Elle peut utiliser chaque potion 1 seule fois dans la partie.',
                actions: [
                    'La sorci√®re se r√©veille',
                    'Vous lui montrez la victime des loups',
                        'Elle peut utiliser sa potion de vie (1 fois)',
                        'Elle peut utiliser sa potion de mort (1 fois)',
                    'La sorci√®re se rendort'
                ]
            },
            {
                    id: 'chasseur',
                    name: 'Chasseur',
                    icon: 'üèπ',
                    category: 'base',
                    phase: 'jour',
                    order: 0,
                    firstNight: false,
                    text: 'Si le chasseur meurt (jour ou nuit), il peut √©liminer quelqu\'un imm√©diatement.',
                    actions: [
                        'Le chasseur est mort',
                        'Il pointe vers un joueur √† √©liminer',
                        'Ce joueur est √©limin√© imm√©diatement'
                    ]
                },
                {
                    id: 'petite_fille',
                    name: 'Petite Fille',
                    icon: 'üëß',
                    category: 'base',
                    phase: 'special',
                    order: 0,
                    firstNight: false,
                    text: 'La petite fille peut entrouvrir les yeux pendant que les loups-garous se r√©veillent pour espionner. Elle est mentionn√©e lors de l\'appel des loups-garous, pas comme un r√¥le s√©par√©.',
                    actions: []
                }
            ],
            extensions: [
                {
                    id: 'infect_pere_loups',
                    name: 'Infect P√®re des Loups',
                    icon: 'üßõ',
                    category: 'extensions',
                    phase: 'nuit',
                    order: 3.6,
                    firstNight: true,
                    everyNight: true,
                    text: 'L\'infect p√®re des loups se r√©veille avec les loups-garous chaque nuit (y compris la premi√®re). Une fois dans la partie, apr√®s que les loups se sont endormis, il peut lever la main pour infecter la victime au lieu de la d√©vorer. La victime devient alors loup-garou.',
                    actions: [
                        'L\'infect p√®re des loups se r√©veille avec les loups',
                        'Les loups choisissent une victime',
                        'Apr√®s que les loups se sont endormis',
                        'Si son pouvoir n\'a pas √©t√© utilis√© : l\'infect peut lever la main pour infecter',
                        'Si oui, touchez la victime - elle devient loup-garou',
                        'Note : pouvoir d\'infection utilisable 1 seule fois dans la partie'
                    ]
                },
                {
                    id: 'grand_mechant_loup',
                    name: 'Grand M√©chant Loup',
                    icon: 'üê∫üí™',
                    category: 'extensions',
                    phase: 'nuit',
                    order: 3.7,
                    firstNight: true,
                    everyNight: true,
                    text: 'Le grand m√©chant loup se r√©veille avec les loups-garous chaque nuit (y compris la premi√®re). Tant qu\'aucun autre loup-garou n\'est √©limin√©, il se r√©veille seul une deuxi√®me fois pour d√©vorer une autre victime (il ne peut pas d√©vorer de loup-garou).',
                    actions: [
                        'Le grand m√©chant loup se r√©veille avec les loups',
                        'Il participe au choix de la victime',
                        'Apr√®s que les loups se sont endormis',
                        'Si aucun autre loup n\'a √©t√© √©limin√©',
                        'Le grand m√©chant loup se r√©veille seul une 2√®me fois',
                        'Il d√©signe une autre victime (pas un loup)',
                        'Vous notez son choix',
                        'Le grand m√©chant loup se rendort'
                    ]
                },
                {
                    id: 'deux_soeurs',
                    name: 'Deux Soeurs',
                    icon: 'üëØ',
                    category: 'extensions',
                    phase: 'nuit',
                    order: 1.8,
                    firstNight: true,
                    text: 'Les deux soeurs se r√©veillent la premi√®re nuit et se reconnaissent. Pour les joueurs exp√©riment√©s : elles peuvent se r√©veiller de temps en temps (un tour sur deux) pour se concerter en silence.',
                    actions: [
                        'Les deux soeurs se r√©veillent',
                        'Elles se reconnaissent',
                        'Elles se rendorment',
                        'Note : peuvent se r√©veiller occasionnellement pour se concerter'
                    ]
                },
                {
                    id: 'renard',
                    name: 'Renard',
                    icon: 'ü¶ä',
                    category: 'extensions',
                    phase: 'nuit',
                    order: 4.5,
                    firstNight: true,
                    everyNight: true,
                    text: 'Le renard se r√©veille chaque nuit (y compris la premi√®re). Il peut d√©signer trois joueurs voisins (en montrant le joueur central). Si au moins un loup-garou est dans ce groupe, il conserve son pouvoir. Sinon, il perd d√©finitivement son pouvoir.',
                    actions: [
                        'Le renard se r√©veille',
                        'Il montre du doigt le joueur central d\'un groupe de trois voisins',
                        'V√©rifiez s\'il y a au moins un loup-garou parmi ces trois',
                        'Faites un signe affirmatif si oui, n√©gatif si non',
                        'Le renard se rendort',
                        'Note : le renard n\'est pas tenu d\'utiliser son pouvoir chaque nuit'
                    ]
                },
                {
                    id: 'chevalier_epee_rouillee',
                    name: 'Chevalier √† l\'√âp√©e Rouill√©e',
                    icon: '‚öîÔ∏èüõ°Ô∏è',
                    category: 'extensions',
                    phase: 'jour',
                    order: 0,
                    firstNight: false,
                    text: 'Si le Chevalier est d√©vor√©, parmi les loups-garous coupables, le premier loup-garou situ√© √† gauche du Chevalier sera √©limin√© au d√©but de la nuit suivante (r√©v√©l√© le matin suivant).',
                    actions: []
                },
                {
                    id: 'ancien',
                    name: 'Ancien',
                    icon: 'üë¥',
                    category: 'extensions',
                    phase: 'jour',
                    order: 0,
                    firstNight: false,
                    text: 'L\'ancien doit √™tre tu√© deux fois pour mourir. Si l\'ancien meurt, tous les villageois perdent leurs pouvoirs.',
                    actions: []
                },
                {
                    id: 'montreur_ours',
                    name: 'Montreur d\'Ours',
                    icon: 'üêª',
                    category: 'extensions',
                    phase: 'jour',
                    order: 0.1,
                    firstNight: false,
                    text: 'Chaque matin, juste apr√®s la r√©v√©lation des victimes nocturnes, si au moins un loup-garou est ou devient un des deux voisins du Montreur d\'Ours, le meneur grogne. Si le Montreur d\'Ours est infect√©, le meneur grogne tous les tours tant qu\'il n\'est pas √©limin√©. Le Montreur d\'Ours est appel√© la premi√®re nuit mais son pouvoir s\'active le matin.',
                    actions: [
                        'Chaque matin, apr√®s la r√©v√©lation des victimes',
                        'V√©rifiez les deux voisins du Montreur d\'Ours',
                        'Si au moins un loup-garou est voisin',
                        'Grognez (faites un son audible par tous)',
                        'Note : seuls les voisins toujours en jeu comptent'
                    ]
                },
                {
                    id: 'enfant_sauvage',
                    name: 'Enfant Sauvage',
                    icon: 'üåø',
                    category: 'extensions',
                    phase: 'nuit',
                    order: 1.9,
                    firstNight: true,
                    text: 'L\'enfant sauvage est un villageois. La premi√®re nuit, il d√©signe un joueur mod√®le. Si le mod√®le est √©limin√©, l\'enfant sauvage devient loup-garou et se r√©veillera avec les loups d√®s la nuit suivante.',
                    actions: [
                        'L\'enfant sauvage se r√©veille',
                        'Il d√©signe son mod√®le',
                        'Vous notez son choix',
                        'L\'enfant sauvage se rendort',
                        'Note : si le mod√®le est √©limin√©, il devient loup-garou'
                    ]
                },
                {
                    id: 'chien_loup',
                    name: 'Chien Loup',
                    icon: 'üêïüê∫',
                    category: 'extensions',
                    phase: 'jour',
                    order: -0.5,
                    firstNight: false,
                    text: 'Au d√©but de la partie, le chien loup choisit s\'il veut √™tre villageois ou loup-garou. Ce choix est d√©finitif.',
                    actions: [
                        'Avant la premi√®re nuit',
                        'Le chien loup se r√©veille',
                        'Il choisit d\'√™tre villageois ou loup-garou',
                        'Vous notez son choix',
                        'Le chien loup se rendort'
                    ]
                },
                {
                    id: 'loup_blanc',
                    name: 'Loup-Garou Blanc',
                    icon: 'üåô',
                    category: 'extensions',
                    phase: 'nuit',
                    order: 3.5,
                    firstNight: true,
                    everyNight: true,
                    text: 'Le loup-garou blanc se r√©veille avec les loups-garous chaque nuit (y compris la premi√®re). Une nuit sur deux, apr√®s que les loups se sont endormis, il se r√©veille seul et peut √©liminer un loup-garou. Son but est de rester le seul survivant.',
                    actions: [
                        'Le loup-garou blanc se r√©veille avec les loups',
                        'Il participe au choix de la victime',
                        'Une nuit sur deux, apr√®s que les loups se sont endormis',
                        'Le loup-garou blanc se r√©veille seul',
                        'Il peut d√©signer un loup-garou √† √©liminer (ou personne)',
                        'Vous notez son choix',
                        'Le loup-garou blanc se rendort'
                    ]
                },
                {
                    id: 'joueur_flute',
                    name: 'Joueur de Fl√ªte',
                    icon: 'üéµ',
                    category: 'extensions',
                    phase: 'nuit',
                    order: 5,
                    firstNight: true,
                    everyNight: true,
                    text: 'Le joueur de fl√ªte charme deux nouveaux joueurs chaque nuit (y compris la premi√®re). Le meneur touche l\'√©paule des charm√©s qui se r√©veillent et se reconnaissent. Si tous les joueurs sont charm√©s, le Joueur de Fl√ªte gagne.',
                    actions: [
                        'Le joueur de fl√ªte se r√©veille',
                        'Il d√©signe 2 nouveaux joueurs √† charmer',
                        'Vous touchez l\'√©paule des nouveaux charm√©s',
                        'Demandez √† tous les charm√©s (anciens et nouveaux) de se r√©veiller',
                        'Ils se reconnaissent puis se rendorment',
                        'Le joueur de fl√ªte se rendort'
                    ]
                },
                {
                    id: 'ange',
                    name: 'Ange',
                    icon: 'üëº',
                    category: 'extensions',
                    phase: 'jour',
                    order: 0,
                    firstNight: false,
                    text: 'Si l\'ange est √©limin√© le premier jour, les villageois gagnent automatiquement. L\'ange essaie donc de se faire √©liminer le premier jour.',
                    actions: []
                }
            ]
        };

        // R√¥les actifs (s√©lectionn√©s par d√©faut)
        let activeRoles = {
            'voyante': true,
            'cupidon': true,
            'loups': true,
            'sorciere': true,
            'chasseur': false,
            'petite_fille': false,
            'infect_pere_loups': false,
            'grand_mechant_loup': false,
            'deux_soeurs': false,
            'renard': false,
            'chevalier_epee_rouillee': false,
            'ancien': false,
            'montreur_ours': false,
            'enfant_sauvage': false,
            'chien_loup': false,
            'loup_blanc': false,
            'joueur_flute': false,
            'ange': false
        };

        // Mapping des noms de r√¥les affich√©s vers les IDs de r√¥les
        const roleNameToId = {
            'Simple Villageois': 'simple_villageois',
            'Cupidon': 'cupidon',
            'Voyante': 'voyante',
            'Petite Fille': 'petite_fille',
            'Deux Soeurs': 'deux_soeurs',
            'Chasseur': 'chasseur',
            'Simple Loups-garous': 'loups',
            'Sorci√®re': 'sorciere',
            'Infect P√®re des Loups': 'infect_pere_loups',
            'Le Grand M√©chant Loup': 'grand_mechant_loup',
            'Renard': 'renard',
            'Chevalier Ep√©e Rouill√©e': 'chevalier_epee_rouillee',
            'Ancien': 'ancien',
            'Montreur Ours': 'montreur_ours',
            'Chein Loup': 'chien_loup',
            'Loup Garou Blanc': 'loup_blanc',
            'Enfant Sauvage': 'enfant_sauvage',
            'Joueur de Fl√ªte': 'joueur_flute',
            'Ange': 'ange'
        };

        // R√©cup√©rer les pr√©noms depuis localStorage (tableau pour chaque r√¥le)
        function getRoleNames() {
            const stored = localStorage.getItem('roleNames');
            const parsed = stored ? JSON.parse(stored) : {};
            // Convertir les anciennes valeurs string en tableaux pour compatibilit√©
            Object.keys(parsed).forEach(key => {
                if (typeof parsed[key] === 'string') {
                    parsed[key] = [parsed[key]];
                }
            });
            return parsed;
        }

        // Sauvegarder les pr√©noms dans localStorage
        function saveRoleNames(roleNames) {
            localStorage.setItem('roleNames', JSON.stringify(roleNames));
        }

        // Obtenir le nom d'affichage d'un r√¥le avec ses pr√©noms si d√©finis
        function getRoleDisplayName(roleName) {
            const roleNames = getRoleNames();
            const firstNames = roleNames[roleName];
            if (firstNames && Array.isArray(firstNames) && firstNames.length > 0) {
                return `${roleName} (${firstNames.join(', ')})`;
            }
            return roleName;
        }

        // Obtenir les pr√©noms d'un r√¥le (retourne un tableau)
        function getRoleFirstNames(roleName) {
            const roleNames = getRoleNames();
            const names = roleNames[roleName];
            return (Array.isArray(names) && names.length > 0) ? names : [];
        }

        // Obtenir le pr√©nom d'un r√¥le (pour compatibilit√©, retourne le premier)
        function getRoleFirstName(roleName) {
            const names = getRoleFirstNames(roleName);
            return names.length > 0 ? names[0] : '';
        }

        // Ajouter un pr√©nom √† un r√¥le (ne remplace pas, ajoute)
        function addRoleFirstName(roleName, firstName) {
            const roleNames = getRoleNames();
            if (firstName && firstName.trim()) {
                const trimmed = firstName.trim();
                if (!roleNames[roleName]) {
                    roleNames[roleName] = [];
                }
                if (!Array.isArray(roleNames[roleName])) {
                    roleNames[roleName] = [roleNames[roleName]];
                }
                // Ne pas ajouter de doublons
                if (!roleNames[roleName].includes(trimmed)) {
                    roleNames[roleName].push(trimmed);
                }
                saveRoleNames(roleNames);
                // R√©g√©n√©rer les phases pour mettre √† jour les affichages
                generatePhases();
                renderPhaseSelector();
                updateDisplay();
                // Mettre √† jour le s√©lecteur de r√¥les dans le menu burger
                renderRoleSelector();
                // Mettre √† jour la gestion des pr√©noms
                renderNamesManagement();
                // Mettre √† jour les cartes d'aide si elles sont affich√©es
                const helpContent = document.getElementById('helpPageContent');
                if (helpContent && helpContent.children.length > 0) {
                    renderRoleHelp(helpContent);
                }
            }
        }

        // Supprimer un pr√©nom sp√©cifique d'un r√¥le
        function removeRoleFirstName(roleName, firstNameToRemove) {
            const roleNames = getRoleNames();
            if (roleNames[roleName] && Array.isArray(roleNames[roleName])) {
                roleNames[roleName] = roleNames[roleName].filter(name => name !== firstNameToRemove);
                if (roleNames[roleName].length === 0) {
                    delete roleNames[roleName];
                }
                saveRoleNames(roleNames);
                // R√©g√©n√©rer les phases pour mettre √† jour les affichages
                generatePhases();
                renderPhaseSelector();
                updateDisplay();
                // Mettre √† jour le s√©lecteur de r√¥les dans le menu burger
                renderRoleSelector();
                // Mettre √† jour la gestion des pr√©noms
                renderNamesManagement();
                // Mettre √† jour les cartes d'aide si elles sont affich√©es
                const helpContent = document.getElementById('helpPageContent');
                if (helpContent && helpContent.children.length > 0) {
                    renderRoleHelp(helpContent);
                }
            }
        }

        // D√©finir le pr√©nom d'un r√¥le (pour compatibilit√©, maintenant utilise addRoleFirstName)
        function setRoleFirstName(roleName, firstName) {
            addRoleFirstName(roleName, firstName);
        }

        // Afficher la confirmation de r√©initialisation
        function showResetConfirmation() {
            const confirmation = document.getElementById('resetConfirmation');
            if (confirmation) {
                confirmation.style.display = 'block';
            }
        }

        // Masquer la confirmation de r√©initialisation
        function hideResetConfirmation() {
            const confirmation = document.getElementById('resetConfirmation');
            if (confirmation) {
                confirmation.style.display = 'none';
            }
        }

        // R√©initialiser tous les pr√©noms
        function resetRoleNames() {
            localStorage.removeItem('roleNames');
            // R√©g√©n√©rer les phases pour mettre √† jour les affichages
            generatePhases();
            renderPhaseSelector();
            renderRoleSelector();
            updateDisplay();
            hideResetConfirmation();
            showToast('‚úÖ Pr√©noms r√©initialis√©s');
        }

        // Phases g√©n√©r√©es dynamiquement selon les r√¥les actifs
        let phases = [];

        let currentPhaseIndex = 0;
        let currentActionIndex = 0;
        let typewriterTimeout = null;
        let isTyping = false;
        let displayedPhaseIndex = -1; // Suivre la phase actuellement affich√©e

        // R√©cup√©rer tous les r√¥les dans une liste plate
        function getAllRolesList() {
            return [...allRoles.base, ...allRoles.extensions];
        }

        // V√©rifier si la Petite Fille est active
        function isPetiteFilleActive() {
            return activeRoles['petite_fille'] || false;
        }

        // G√©n√©rer les phases selon les r√¥les actifs
        function generatePhases() {
            const newPhases = [];
            
            // Phase de d√©but
            newPhases.push({
                id: 'start',
                title: 'D√©but de la partie',
                text: 'Distribuez les cartes aux joueurs et expliquez les r√®gles si n√©cessaire. Chaque joueur regarde secr√®tement sa carte.',
                actions: []
            });

            // Si l'Ange est en jeu, commencer par un d√©bat/vote avant la premi√®re nuit
            if (activeRoles['ange']) {
                newPhases.push({
                    id: 'ange_premier_jour',
                    title: 'üëº Premier Jour (Ange en jeu)',
                    text: 'Si l\'Ange est √©limin√© ce premier jour, les villageois gagnent automatiquement. L\'Ange essaie de se faire √©liminer.',
                    actions: [
                        'D√©bat du village (premier jour sp√©cial)',
                        'Le village vote pour √©liminer quelqu\'un',
                        'Si l\'Ange est √©limin√©, les villageois gagnent imm√©diatement',
                        'Sinon, le jeu continue avec la premi√®re nuit'
                    ]
                });
            }

            // R√¥les qui se r√©veillent avant la premi√®re nuit (comme Chien Loup)
            const beforeFirstNightRoles = getAllRolesList()
                .filter(role => activeRoles[role.id] && role.phase === 'jour' && role.order < 0)
                .sort((a, b) => a.order - b.order);

            beforeFirstNightRoles.forEach(role => {
                newPhases.push({
                    id: role.id,
                    title: `${role.icon} ${getRoleDisplayName(role.name)}`,
                    text: role.text,
                    actions: role.actions || []
                });
            });

            // Premi√®re nuit : tous les r√¥les qui se r√©veillent la premi√®re nuit (y compris ceux qui se r√©veillent aussi chaque nuit)
            // Exclure la Petite Fille qui n'est pas un r√¥le qui se r√©veille s√©par√©ment
            const allFirstNightRoles = getAllRolesList()
                .filter(role => activeRoles[role.id] && role.firstNight && role.phase === 'nuit' && role.id !== 'petite_fille')
                .sort((a, b) => a.order - b.order);

            // Compter combien de r√¥les seront r√©ellement ajout√©s apr√®s la phase "Premi√®re Nuit"
            let rolesToAddCount = 0;
            if (allFirstNightRoles.length > 0) {
                // Cupidon
                if (allFirstNightRoles.some(r => r.id === 'cupidon')) rolesToAddCount++;
                // Voyante
                if (allFirstNightRoles.some(r => r.id === 'voyante')) rolesToAddCount++;
                // Deux S≈ìurs
                if (allFirstNightRoles.some(r => r.id === 'deux_soeurs')) rolesToAddCount++;
                // Enfant Sauvage
                if (allFirstNightRoles.some(r => r.id === 'enfant_sauvage')) rolesToAddCount++;
                // Loups
                if (allFirstNightRoles.some(r => r.id === 'loups')) rolesToAddCount++;
                // Infect
                if (allFirstNightRoles.some(r => r.id === 'infect_pere_loups')) rolesToAddCount++;
                // Grand M√©chant
                if (allFirstNightRoles.some(r => r.id === 'grand_mechant_loup')) rolesToAddCount++;
                // Sorci√®re
                if (allFirstNightRoles.some(r => r.id === 'sorciere')) rolesToAddCount++;
                // Renard
                if (allFirstNightRoles.some(r => r.id === 'renard')) rolesToAddCount++;
                // Joueur de Fl√ªte
                if (allFirstNightRoles.some(r => r.id === 'joueur_flute')) rolesToAddCount++;
            }

            // Ne cr√©er la phase "Premi√®re Nuit" que si au moins un r√¥le sera ajout√©
            if (rolesToAddCount > 0) {
                newPhases.push({
                    id: 'nuit1',
                    title: 'üåô Premi√®re Nuit',
                    text: 'Tout le monde ferme les yeux. C\'est la premi√®re nuit.',
                    actions: ['Tous les joueurs ferment les yeux']
                });

                // Ajouter les r√¥les selon l'ordre exact de la premi√®re nuit (page 22 des r√®gles)
                // Ordre premi√®re nuit : Cupidon(0) ‚Üí Voyante(1) ‚Üí 2 S≈ìurs(1.8) ‚Üí Enfant Sauvage(1.9) ‚Üí Tous Loups(3, incluant Loup Blanc, Infect, Grand-M√©chant) ‚Üí Infect(3.6, apr√®s loups) ‚Üí Grand-M√©chant(3.7, apr√®s loups) ‚Üí Sorci√®re(4) ‚Üí Renard(4.5) ‚Üí Joueur Fl√ªte(5)
                
                // Cupidon
                const cupidon = allFirstNightRoles.find(r => r.id === 'cupidon');
                if (cupidon) {
                    newPhases.push({
                        id: cupidon.id,
                        title: `${cupidon.icon} ${getRoleDisplayName(cupidon.name)}`,
                        text: cupidon.text,
                        actions: cupidon.actions || []
                    });
                }
                
                // Voyante
                const voyante = allFirstNightRoles.find(r => r.id === 'voyante');
                if (voyante) {
                    newPhases.push({
                        id: voyante.id,
                        title: `${voyante.icon} ${getRoleDisplayName(voyante.name)}`,
                        text: voyante.text,
                        actions: voyante.actions || []
                    });
                }
                
                // Deux S≈ìurs
                const deuxSoeurs = allFirstNightRoles.find(r => r.id === 'deux_soeurs');
                if (deuxSoeurs) {
                    newPhases.push({
                        id: deuxSoeurs.id,
                        title: `${deuxSoeurs.icon} ${getRoleDisplayName(deuxSoeurs.name)}`,
                        text: deuxSoeurs.text,
                        actions: deuxSoeurs.actions || []
                    });
                }
                
                // Enfant Sauvage
                const enfantSauvage = allFirstNightRoles.find(r => r.id === 'enfant_sauvage');
                if (enfantSauvage) {
                    newPhases.push({
                        id: enfantSauvage.id,
                        title: `${enfantSauvage.icon} ${getRoleDisplayName(enfantSauvage.name)}`,
                        text: enfantSauvage.text,
                        actions: enfantSauvage.actions || []
                    });
                }
                
                // Loups-Garous (y compris Chien-Loup s'il a choisi loup, Loup-Garou Blanc, Infect P√®re des Loups, Grand-M√©chant-Loup)
                // Avec mention Petite Fille si active
                const loups = allFirstNightRoles.find(r => r.id === 'loups');
                const hasLoupBlanc = allFirstNightRoles.some(r => r.id === 'loup_blanc');
                const hasInfect = allFirstNightRoles.some(r => r.id === 'infect_pere_loups');
                const hasGrandMechant = allFirstNightRoles.some(r => r.id === 'grand_mechant_loup');
                const hasChienLoup = activeRoles['chien_loup'];
                
                if (loups) {
                    let loupsText = 'Les loups-garous se r√©veillent et se reconnaissent.';
                    if (hasLoupBlanc) loupsText += ' Le Loup-Garou Blanc se r√©veille avec eux.';
                    if (hasInfect) loupsText += ' L\'Infect P√®re des Loups se r√©veille avec eux.';
                    if (hasGrandMechant) loupsText += ' Le Grand-M√©chant-Loup se r√©veille avec eux.';
                    if (hasChienLoup) loupsText += ' Le Chien-Loup se r√©veille avec eux s\'il a choisi d\'√™tre loup.';
                    loupsText += ' Ils d√©signent une victime.';
                    if (isPetiteFilleActive()) {
                        loupsText += ' La Petite Fille peut entrouvrir les yeux pour espionner.';
                    }
                    
                    newPhases.push({
                        id: loups.id,
                        title: `${loups.icon} ${getRoleDisplayName(loups.name)}`,
                        text: loupsText,
                        actions: loups.actions || []
                    });
                }
                
                // Infect P√®re des Loups (apr√®s que les loups se sont endormis)
                const infect = allFirstNightRoles.find(r => r.id === 'infect_pere_loups');
                if (infect) {
                    newPhases.push({
                        id: infect.id,
                        title: `${infect.icon} ${getRoleDisplayName(infect.name)}`,
                        text: infect.text,
                        actions: infect.actions || []
                    });
                }
                
                // Grand-M√©chant-Loup (apr√®s que les loups se sont endormis, si aucun loup n'est √©limin√©)
                const grandMechant = allFirstNightRoles.find(r => r.id === 'grand_mechant_loup');
                if (grandMechant) {
                    newPhases.push({
                        id: grandMechant.id,
                        title: `${grandMechant.icon} ${getRoleDisplayName(grandMechant.name)}`,
                        text: grandMechant.text,
                        actions: grandMechant.actions || []
                    });
                }
                
                // Sorci√®re
                const sorciere = allFirstNightRoles.find(r => r.id === 'sorciere');
                if (sorciere) {
                    newPhases.push({
                        id: sorciere.id,
                        title: `${sorciere.icon} ${getRoleDisplayName(sorciere.name)}`,
                        text: sorciere.text,
                        actions: sorciere.actions || []
                    });
                }
                
                // Renard
                const renard = allFirstNightRoles.find(r => r.id === 'renard');
                if (renard) {
                    newPhases.push({
                        id: renard.id,
                        title: `${renard.icon} ${getRoleDisplayName(renard.name)}`,
                        text: renard.text,
                        actions: renard.actions || []
                    });
                }
                
                // Joueur de Fl√ªte
                const joueurFlute = allFirstNightRoles.find(r => r.id === 'joueur_flute');
                if (joueurFlute) {
                    newPhases.push({
                        id: joueurFlute.id,
                        title: `${joueurFlute.icon} ${getRoleDisplayName(joueurFlute.name)}`,
                        text: joueurFlute.text,
                        actions: joueurFlute.actions || []
                    });
                }
                
            }

            // Phase du jour
            newPhases.push({
                id: 'jour',
                title: '‚òÄÔ∏è Le Jour se L√®ve',
                text: 'Tout le monde se r√©veille. Annoncez qui est mort pendant la nuit (ou que personne n\'est mort).',
                actions: [
                    'Tous les joueurs se r√©veillent',
                    'Annoncez les morts de la nuit',
                    'Les morts peuvent faire une derni√®re d√©claration',
                    'V√©rifiez le Montreur d\'Ours (grognez si un loup est voisin)',
                    'D√©bat et vote pour √©liminer quelqu\'un'
                ]
            });

            // Phase de vote
            newPhases.push({
                id: 'vote',
                title: 'üó≥Ô∏è Vote',
                text: 'Les joueurs votent pour √©liminer un suspect. Le joueur avec le plus de votes est √©limin√©.',
                actions: [
                    'Comptez les votes',
                    'Annoncez le joueur √©limin√©',
                    'Montrez sa carte',
                    'Le joueur √©limin√© peut faire une derni√®re d√©claration'
                ]
            });

            // Phase de nuit suivante (mod√®le r√©utilisable)
            // Ordre chaque nuit selon r√®gles : Sorci√®re ‚Üí Voyante ‚Üí Renard ‚Üí Loups ‚Üí Joueur Fl√ªte ‚Üí Loup Blanc(1/2) ‚Üí Infect ‚Üí Grand-M√©chant
            const rolesForEveryNight = getAllRolesList()
                .filter(role => activeRoles[role.id] && role.phase === 'nuit' && (role.everyNight === true) && role.id !== 'cupidon' && role.id !== 'deux_soeurs' && role.id !== 'enfant_sauvage' && role.id !== 'petite_fille')
                .sort((a, b) => {
                    // Ordre sp√©cial pour chaque nuit selon r√®gles : Sorci√®re ‚Üí Voyante ‚Üí Renard ‚Üí Loups ‚Üí Joueur Fl√ªte ‚Üí Loup Blanc(1/2) ‚Üí Infect ‚Üí Grand-M√©chant
                    const orderMap = {
                        'sorciere': 0.5,
                        'voyante': 1,
                        'renard': 1.3,
                        'loups': 3,
                        'joueur_flute': 5,
                        'loup_blanc': 6,
                        'infect_pere_loups': 6.5,
                        'grand_mechant_loup': 7
                    };
                    return (orderMap[a.id] || a.order) - (orderMap[b.id] || b.order);
                });

            if (rolesForEveryNight.length > 0) {
                newPhases.push({
                    id: 'nuit_suivante',
                    title: 'üåô Nuit',
                    text: 'Tout le monde ferme les yeux. C\'est une nuit normale.',
                    actions: ['Tous les joueurs ferment les yeux']
                });

                rolesForEveryNight.forEach(role => {
                    // Pour les loups, ajouter mention Petite Fille si active
                    if (role.id === 'loups' && isPetiteFilleActive()) {
                        newPhases.push({
                            id: role.id + '_nuit',
                            title: `${role.icon} ${getRoleDisplayName(role.name)}`,
                            text: role.text + ' La Petite Fille peut entrouvrir les yeux pour espionner.',
                            actions: role.actions || []
                        });
                    } else {
                        newPhases.push({
                            id: role.id + '_nuit',
                            title: `${role.icon} ${getRoleDisplayName(role.name)}`,
                            text: role.text,
                            actions: role.actions || []
                        });
                    }
                });
            }

            // Phase de fin
            newPhases.push({
                id: 'fin',
                title: 'üéØ Fin de Partie',
                text: 'V√©rifiez les conditions de victoire : les villageois gagnent si tous les loups-garous sont √©limin√©s, les loups-garous gagnent s\'ils sont en nombre √©gal ou sup√©rieur aux villageois.',
                actions: []
            });

            phases = newPhases;
            currentPhaseIndex = Math.min(currentPhaseIndex, phases.length - 1);
            displayedPhaseIndex = -1; // Forcer le re-render lors du prochain updateDisplay
        }

        // Rendre l'interface de s√©lection des r√¥les
        function renderRoleSelector() {
            const container = document.getElementById('roleCategories');
            container.innerHTML = '';

            // R√¥les de base
            const baseCategory = document.createElement('div');
            baseCategory.className = 'role-category';
            baseCategory.innerHTML = '<div class="role-category-title">üéÆ R√¥les de Base</div>';
            const baseList = document.createElement('div');
            baseList.className = 'role-list';

            allRoles.base.forEach(role => {
                const item = createRoleCheckbox(role);
                baseList.appendChild(item);
            });

            baseCategory.appendChild(baseList);
            container.appendChild(baseCategory);

            // R√¥les des extensions
            const extCategory = document.createElement('div');
            extCategory.className = 'role-category';
            extCategory.innerHTML = '<div class="role-category-title">üì¶ Extensions</div>';
            const extList = document.createElement('div');
            extList.className = 'role-list';

            allRoles.extensions.forEach(role => {
                const item = createRoleCheckbox(role);
                extList.appendChild(item);
            });

            extCategory.appendChild(extList);
            container.appendChild(extCategory);
            
            // Mettre √† jour la liste des √©liminations
            renderEliminationList();
            
            // Mettre √† jour la gestion des pr√©noms
            renderNamesManagement();
        }

        // Afficher la gestion des pr√©noms dans le menu burger
        function renderNamesManagement() {
            const namesList = document.getElementById('namesManagementList');
            if (!namesList) return;
            
            namesList.innerHTML = '';
            
            const roleNames = getRoleNames();
            const rolesWithNames = Object.keys(roleNames).filter(roleName => {
                const names = roleNames[roleName];
                return Array.isArray(names) && names.length > 0;
            });
            
            if (rolesWithNames.length === 0) {
                namesList.innerHTML = '<p style="text-align: center; color: #CCB895; font-size: 0.9rem; padding: 10px;">Aucun pr√©nom d√©fini</p>';
                return;
            }
            
            rolesWithNames.forEach(roleName => {
                const roleNamesArray = roleNames[roleName];
                
                roleNamesArray.forEach(firstName => {
                    const item = document.createElement('div');
                    item.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; margin: 5px 0; background: rgba(0, 0, 0, 0.2); border-radius: 5px; border-left: 3px solid rgba(37, 150, 190, 0.5);';
                    
                    const roleInfo = document.createElement('span');
                    roleInfo.style.cssText = 'flex: 1; color: #FFE4B5; font-size: 0.9rem;';
                    roleInfo.textContent = `${roleName}: ${firstName}`;
                    
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = '‚úï';
                    deleteBtn.style.cssText = 'padding: 5px 10px; background: rgba(255, 100, 100, 0.3); color: #FFB84D; border: 1px solid rgba(255, 100, 100, 0.5); border-radius: 5px; cursor: pointer; font-size: 0.9rem; transition: all 0.3s;';
                    deleteBtn.onmouseenter = function() {
                        this.style.background = 'rgba(255, 100, 100, 0.5)';
                        this.style.transform = 'scale(1.1)';
                    };
                    deleteBtn.onmouseleave = function() {
                        this.style.background = 'rgba(255, 100, 100, 0.3)';
                        this.style.transform = 'scale(1)';
                    };
                    deleteBtn.onclick = () => {
                        removeRoleFirstName(roleName, firstName);
                        renderNamesManagement();
                    };
                    
                    item.appendChild(roleInfo);
                    item.appendChild(deleteBtn);
                    namesList.appendChild(item);
                });
            });
        }

        // Afficher la liste des r√¥les actifs pour √©limination
        function renderEliminationList() {
            const eliminationList = document.getElementById('eliminationList');
            if (!eliminationList) return;
            
            eliminationList.innerHTML = '';
            
            // R√©cup√©rer tous les r√¥les actifs (exclure les loups-garous car il y en a plusieurs)
            const activeRolesList = getAllRolesList().filter(role => activeRoles[role.id] && role.id !== 'loups');
            
            if (activeRolesList.length === 0) {
                eliminationList.innerHTML = '<p style="text-align: center; color: #CCB895; font-size: 0.9rem; padding: 10px;">Aucun r√¥le actif</p>';
                return;
            }
            
            activeRolesList.forEach(role => {
                const item = document.createElement('div');
                item.style.cssText = 'display: flex; align-items: center; justify-content: space-between; padding: 8px 10px; margin: 5px 0; background: rgba(0, 0, 0, 0.2); border-radius: 5px; border-left: 3px solid rgba(255, 100, 100, 0.5);';
                
                const roleInfo = document.createElement('span');
                roleInfo.style.cssText = 'flex: 1; color: #FFE4B5; font-size: 0.9rem;';
                roleInfo.textContent = `${role.icon} ${getRoleDisplayName(role.name)}`;
                
                const eliminateBtn = document.createElement('button');
                eliminateBtn.textContent = '‚ö∞Ô∏è';
                eliminateBtn.style.cssText = 'padding: 5px 10px; background: rgba(255, 100, 100, 0.3); color: #FFB84D; border: 1px solid rgba(255, 100, 100, 0.5); border-radius: 5px; cursor: pointer; font-size: 1rem; transition: all 0.3s;';
                eliminateBtn.onmouseenter = function() {
                    this.style.background = 'rgba(255, 100, 100, 0.5)';
                    this.style.transform = 'scale(1.1)';
                };
                eliminateBtn.onmouseleave = function() {
                    this.style.background = 'rgba(255, 100, 100, 0.3)';
                    this.style.transform = 'scale(1)';
                };
                eliminateBtn.onclick = () => {
                    showEliminationConfirmation(role.id, role.name, item);
                };
                
                item.appendChild(roleInfo);
                item.appendChild(eliminateBtn);
                eliminationList.appendChild(item);
            });
        }

        // Afficher la confirmation d'√©limination
        function showEliminationConfirmation(roleId, roleName, itemElement) {
            // Masquer toutes les autres confirmations ouvertes
            document.querySelectorAll('.elimination-confirmation').forEach(el => el.remove());
            
            // Cr√©er la confirmation
            const confirmation = document.createElement('div');
            confirmation.className = 'elimination-confirmation';
            confirmation.style.cssText = 'margin-top: 10px; padding: 10px; background: rgba(0, 0, 0, 0.4); border-radius: 5px; text-align: center; border: 1px solid rgba(255, 100, 100, 0.5);';
            
            const message = document.createElement('p');
            message.style.cssText = 'color: #FFE4B5; font-size: 0.9rem; margin-bottom: 10px;';
            message.textContent = `√âliminer ${roleName} ?`;
            
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center;';
            
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = '‚úì';
            confirmBtn.style.cssText = 'padding: 5px 15px; background: rgba(100, 255, 100, 0.3); color: #FFE4B5; border: 1px solid rgba(100, 255, 100, 0.5); border-radius: 5px; cursor: pointer; font-size: 1.2rem; transition: all 0.3s;';
            confirmBtn.onmouseenter = function() {
                this.style.background = 'rgba(100, 255, 100, 0.5)';
                this.style.transform = 'scale(1.1)';
            };
            confirmBtn.onmouseleave = function() {
                this.style.background = 'rgba(100, 255, 100, 0.3)';
                this.style.transform = 'scale(1)';
            };
            confirmBtn.onclick = () => {
                eliminateRole(roleId, roleName);
            };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = '‚úï';
            cancelBtn.style.cssText = 'padding: 5px 15px; background: rgba(255, 100, 100, 0.3); color: #FFE4B5; border: 1px solid rgba(255, 100, 100, 0.5); border-radius: 5px; cursor: pointer; font-size: 1.2rem; transition: all 0.3s;';
            cancelBtn.onmouseenter = function() {
                this.style.background = 'rgba(255, 100, 100, 0.5)';
                this.style.transform = 'scale(1.1)';
            };
            cancelBtn.onmouseleave = function() {
                this.style.background = 'rgba(255, 100, 100, 0.3)';
                this.style.transform = 'scale(1)';
            };
            cancelBtn.onclick = () => {
                confirmation.remove();
            };
            
            buttonsContainer.appendChild(confirmBtn);
            buttonsContainer.appendChild(cancelBtn);
            confirmation.appendChild(message);
            confirmation.appendChild(buttonsContainer);
            
            // Ajouter la confirmation apr√®s l'√©l√©ment
            itemElement.appendChild(confirmation);
        }

        // √âliminer un r√¥le
        function eliminateRole(roleId, roleName) {
            activeRoles[roleId] = false;
            
            // Retirer la confirmation
            document.querySelectorAll('.elimination-confirmation').forEach(el => el.remove());
            
            // Mettre √† jour la checkbox dans le s√©lecteur
            const checkbox = document.getElementById(`role-${roleId}`);
            if (checkbox) {
                checkbox.checked = false;
                const item = checkbox.closest('.role-item');
                if (item) {
                    item.classList.remove('active');
                }
            }
            
            // R√©g√©n√©rer les phases
            generatePhases();
            renderPhaseSelector();
            updateDisplay();
            
            // Mettre √† jour les listes
            renderEliminationList();
            renderRoleSelector();
            
            showToast(`‚ö∞Ô∏è ${roleName} a √©t√© √©limin√©`);
        }

        // Cr√©er une checkbox pour un r√¥le
        function createRoleCheckbox(role) {
            const item = document.createElement('div');
            item.className = `role-item ${activeRoles[role.id] ? 'active' : ''}`;
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `role-${role.id}`;
            checkbox.checked = activeRoles[role.id] || false;
            checkbox.onchange = () => {
                activeRoles[role.id] = checkbox.checked;
                item.classList.toggle('active', checkbox.checked);
                generatePhases();
                renderPhaseSelector();
                updateDisplay();
                renderEliminationList();
            };

            const label = document.createElement('label');
            label.htmlFor = `role-${role.id}`;
            label.textContent = `${role.icon} ${getRoleDisplayName(role.name)}`;

            item.appendChild(checkbox);
            item.appendChild(label);

            return item;
        }

        // Toggle tous les r√¥les
        function toggleAllRoles(enable) {
            getAllRolesList().forEach(role => {
                activeRoles[role.id] = enable;
                const checkbox = document.getElementById(`role-${role.id}`);
                if (checkbox) {
                    checkbox.checked = enable;
                    const item = checkbox.closest('.role-item');
                    if (item) {
                        item.classList.toggle('active', enable);
                    }
                }
            });
            generatePhases();
            renderPhaseSelector();
            updateDisplay();
            renderEliminationList();
        }

        // Afficher la demande de code
        function showCodeInput() {
            // Cr√©er l'overlay et le conteneur de code
            const existingOverlay = document.getElementById('codeInputOverlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
            
            const overlay = document.createElement('div');
            overlay.id = 'codeInputOverlay';
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); z-index: 5000; display: flex; align-items: center; justify-content: center;';
            
            const container = document.createElement('div');
            container.style.cssText = 'background: rgba(0, 0, 0, 0.9); padding: 30px; border-radius: 15px; border: 2px solid rgba(255, 140, 0, 0.5); max-width: 400px; width: 90%; text-align: center;';
            
            const title = document.createElement('h3');
            title.style.cssText = 'color: #FFE4B5; font-size: 1.3rem; margin-bottom: 20px;';
            title.textContent = 'üîí Code d\'acc√®s';
            
            const input = document.createElement('input');
            input.type = 'password';
            input.id = 'codeInput';
            input.placeholder = 'Entrez le code';
            input.style.cssText = 'width: 100%; padding: 12px; font-size: 1.2rem; text-align: center; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 140, 0, 0.5); border-radius: 8px; color: #FFE4B5; margin-bottom: 20px;';
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    validateCode(input.value);
                }
            });
            
            const buttonsContainer = document.createElement('div');
            buttonsContainer.style.cssText = 'display: flex; gap: 10px; justify-content: center;';
            
            const confirmBtn = document.createElement('button');
            confirmBtn.textContent = '‚úì';
            confirmBtn.style.cssText = 'padding: 10px 20px; background: rgba(100, 255, 100, 0.3); color: #FFE4B5; border: 1px solid rgba(100, 255, 100, 0.5); border-radius: 8px; cursor: pointer; font-size: 1.5rem; transition: all 0.3s;';
            confirmBtn.onmouseenter = function() {
                this.style.background = 'rgba(100, 255, 100, 0.5)';
                this.style.transform = 'scale(1.1)';
            };
            confirmBtn.onmouseleave = function() {
                this.style.background = 'rgba(100, 255, 100, 0.3)';
                this.style.transform = 'scale(1)';
            };
            confirmBtn.onclick = () => {
                validateCode(input.value);
            };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = '‚úï';
            cancelBtn.style.cssText = 'padding: 10px 20px; background: rgba(255, 100, 100, 0.3); color: #FFE4B5; border: 1px solid rgba(255, 100, 100, 0.5); border-radius: 8px; cursor: pointer; font-size: 1.5rem; transition: all 0.3s;';
            cancelBtn.onmouseenter = function() {
                this.style.background = 'rgba(255, 100, 100, 0.5)';
                this.style.transform = 'scale(1.1)';
            };
            cancelBtn.onmouseleave = function() {
                this.style.background = 'rgba(255, 100, 100, 0.3)';
                this.style.transform = 'scale(1)';
            };
            cancelBtn.onclick = () => {
                overlay.remove();
                if (window.codeInputResolve) {
                    window.codeInputResolve(false);
                    window.codeInputResolve = null;
                }
            };
            
            buttonsContainer.appendChild(confirmBtn);
            buttonsContainer.appendChild(cancelBtn);
            
            container.appendChild(title);
            container.appendChild(input);
            container.appendChild(buttonsContainer);
            overlay.appendChild(container);
            
            document.body.appendChild(overlay);
            
            // Focus sur l'input
            setTimeout(() => {
                input.focus();
            }, 100);
            
            return new Promise((resolve) => {
                window.codeInputResolve = resolve;
            });
        }
        
        // Valider le code saisi
        function validateCode(code) {
            const overlay = document.getElementById('codeInputOverlay');
            if (code === '3233') {
                if (overlay) overlay.remove();
                if (window.codeInputResolve) {
                    window.codeInputResolve(true);
                    window.codeInputResolve = null;
                }
            } else {
                showToast('‚ùå Code incorrect');
                const input = document.getElementById('codeInput');
                if (input) {
                    input.value = '';
                    input.focus();
                }
            }
        }

        // V√©rifier si le code est correct (toujours false pour redemander √† chaque fois)
        function checkMenuCode() {
            // Toujours retourner false pour demander le code √† chaque ouverture
            return false;
        }

        // Toggle le menu burger (fonction unique utilis√©e partout)
        function toggleBurgerMenu() {
            const panel = document.getElementById('roleSelectorPanel');
            const overlay = document.getElementById('menuOverlay');
            const burgerBtn = document.getElementById('burgerMenuBtn');
            const helpBurgerBtn = document.getElementById('helpBurgerMenuBtn');
            
            if (!panel || !overlay) {
                console.error('Menu panel ou overlay introuvable');
                return;
            }
            
            const isActive = panel.classList.contains('active');
            
            if (isActive) {
                // Fermer le menu
                panel.classList.remove('active');
                overlay.classList.remove('active');
            } else {
                // V√©rifier le code avant d'ouvrir le menu
                if (!checkMenuCode()) {
                    // Afficher l'input de code et ouvrir le menu apr√®s validation
                    showCodeInput().then((valid) => {
                        if (valid) {
                            panel.classList.add('active');
                            overlay.classList.add('active');
                            if (burgerBtn) burgerBtn.classList.add('active');
                            if (helpBurgerBtn) helpBurgerBtn.classList.add('active');
                        }
                    });
                    return; // Ne pas ouvrir le menu imm√©diatement
                }
                // Ouvrir le menu
                panel.classList.add('active');
                overlay.classList.add('active');
            }
            
            // Mettre √† jour tous les boutons burger (celui de la page principale et celui de la page d'aide)
            if (burgerBtn) {
                burgerBtn.classList.toggle('active');
            }
            if (helpBurgerBtn) {
                helpBurgerBtn.classList.toggle('active');
            }
        }


        // Descriptions des r√¥les selon les r√®gles officielles
        const roleDescriptions = {
            'Simple Villageois': {
                image: 'Simple Villageois.png',
                description: 'Il n\'a aucune comp√©tence particuli√®re. Ses seules armes sont sa capacit√© d\'analyse des comportements pour identifier les Loups-Garous, et sa force de conviction pour emp√™cher l\'ex√©cution de l\'innocent qu\'il est. En fin de journ√©e, comme les autres habitants du village, il participera au vote d\'√©limination de l\'un d\'entre eux.'
            },
            'Cupidon': {
                image: 'Cupidon.png',
                description: 'En d√©cochant ses c√©l√®bres fl√®ches magiques, Cupidon a le pouvoir de rendre 2 personnes amoureuses √† jamais. La premi√®re nuit (tour pr√©liminaire), il d√©signe au meneur les 2 joueurs (ou joueuses) amoureux. Cupidon peut, s\'il le veut, se d√©signer comme l\'un des deux amoureux. Le meneur r√©veille ensuite les amoureux pour qu\'ils se reconnaissent. Afin de vivre pleinement leur amour, l\'espoir des amoureux est de survivre tous les deux jusqu\'√† la fin du jeu. Si l\'un des amoureux est √©limin√©, l\'autre meurt de chagrin imm√©diatement. Un amoureux ne doit jamais √©liminer son aim√©, ni lui porter aucun pr√©judice (m√™me pour faire semblant !). Attention : si l\'un des amoureux est villageois et l\'autre un Loup-Garou, les amoureux gagnent la partie s\'ils survivent √† tous les autres joueurs.'
            },
            'Voyante': {
                image: 'Voyante.png',
                description: 'Chaque nuit, le meneur la r√©veille afin qu\'elle lui d√©signe un joueur dont elle veut conna√Ætre l\'identit√©. Il lui montre la carte du joueur d√©sign√©, puis elle se rendort. Elle doit aider les autres villageois, mais rester discr√®te pour ne pas √™tre d√©masqu√©e par les Loups-Garous.'
            },
            'Petite Fille': {
                image: 'Petite Fille.png',
                description: 'La Petite Fille peut, en entrouvrant les yeux, espionner les Loups-Garous pendant leur √©veil. Si elle se fait surprendre par un des Loups-Garous, elle pourra √™tre d√©vor√©e imm√©diatement (en silence), √† la place de la victime d√©sign√©e. La Petite Fille ne peut espionner que la nuit, durant le tour d\'√©veil des Loups-Garous. Elle n\'a pas le droit de se faire passer pour un Loup-Garou et d\'ouvrir grand les yeux.'
            },
            'Deux Soeurs': {
                image: 'Deux Soeurs.png',
                description: 'La premi√®re nuit, √† l\'appel du meneur, elles se r√©veillent ensemble, se reconnaissent puis se rendorment. Pour les joueurs exp√©riment√©s : au cours de la partie, de temps en temps (un tour sur deux ou au gr√© du meneur), elles se r√©veillent √† nouveau et se concertent rapidement et en silence sur les d√©cisions √† prendre pour sauver le village (particuli√®rement puisant avec des pratiquants de la langue des signes).'
            },
            'Chasseur': {
                image: 'Chasseur.png',
                description: 'Lorsqu\'il est √©limin√©, et quelle qu\'en soit la cause, imm√©diatement apr√®s la r√©v√©lation de sa carte, le Chasseur r√©plique en √©liminant un autre joueur. Pour se prot√©ger, certains joueurs n\'h√©siteront pas √† se faire passer pour le Chasseur au moment du d√©bat du village. Attention : le Chasseur est avant tout un villageois et c\'est un Loup-Garou qu\'il esp√®re entra√Æner avec lui dans sa chute. Mais, s\'il a √©t√© infect√© par l\'Infect P√®re des Loups, le Chasseur pr√©f√©rera √©liminer des villageois qu\'il sait innocents afin de faire gagner son camp.'
            },
            'Simple Loups-garous': {
                image: 'Simple Loups-garous.png',
                description: 'Chaque nuit √† l\'appel du meneur de jeu ils se r√©veillent en toute discr√©tion. Ils se concertent silencieusement, puis d√©signent un des habitants du village. La victime ne peut en aucun cas √™tre un Loup-Garou. Le joueur ainsi d√©vor√© est √©limin√© de la partie. Il ne pourra plus intervenir dans le jeu. Le jour, les Loups-Garous essaient de masquer leur identit√© nocturne pour √©chapper √† la vindicte populaire.'
            },
            'Infect P√®re des Loups': {
                image: 'Infect P√®re des Loups.png',
                description: 'Le tout premier Loup-Garou de nos contr√©es, le p√®re de tous leurs p√®res, a un pouvoir suppl√©mentaire, celui de propager son engeance par une morsure sp√©ciale. Chaque nuit, il se r√©veille et d√©vore un villageois avec les autres Loups-Garous. Mais une fois dans la partie, s\'il le d√©sire, apr√®s que les Loups-Garous se sont endormis, il l√®ve la main. Cela signifie que la victime n\'est pas d√©vor√©e mais infect√©e. L\'Infect P√®re des Loups ne peut utiliser son pouvoir sp√©cial qu\'une seule fois dans la partie. Le meneur touche alors cet habitant infect√© qui devient imm√©diatement (et secr√®tement) simple Loup-Garou. Il participera d√©sormais toutes les nuits au festin des Loups-Garous. S\'il poss√©dait un pouvoir nocturne, il sera r√©veill√© par le meneur les tours suivants pour utiliser ce pouvoir, en plus d\'√™tre appel√© avec les Loups-Garous.'
            },
            'Le Grand M√©chant Loup': {
                image: 'Le Grand M√©chant Loup.png',
                description: '√Ä Thiercelieux, les petits cochons ne sont pas les seuls √† redouter le Grand-M√©chant-Loup. Il est √©norme et son app√©tit est gigantesque. √Ä cause de lui, des villages entiers furent ray√©s de la carte ! Chaque nuit, il se r√©veille et d√©vore un villageois avec les autres Loups-Garous. Mais tant qu\'aucun autre Loup-Garou n\'est √©limin√©, il se r√©veille seul une deuxi√®me fois et d√©vore une autre victime. Il ne peut pas d√©vorer de Loup-Garou.'
            },
            'Renard': {
                image: 'Renard.png',
                description: '√Ä Thiercelieux, tout le monde appr√©cie le flair de ce personnage vif et discret, sauf peut-√™tre les poules et surtout les Loups-Garous ! La nuit, √† l\'appel du meneur, le Renard peut d√©signer un groupe de trois joueurs voisins, dont il montre du doigt le joueur central (les joueurs √©limin√©s ne sont pas pris en compte). Si dans ce groupe se trouve au moins un Loup-Garou, alors le meneur fait un signe affirmatif au Renard. Dans ce cas, le Renard pourra utiliser √† nouveau son pouvoir une nuit suivante. Si aucun Loup-Garou ne fait partie du groupe d√©sign√©, le Renard perd d√©finitivement son pouvoir ; par contre, il b√©n√©ficie d\'une information de taille innocentant trois joueurs d\'un coup. Remarque : le meneur appelle le Renard toutes les nuits, mais celui-ci n\'est en aucun cas tenu d\'utiliser son pouvoir chaque nuit.'
            },
            'Chevalier Ep√©e Rouill√©e': {
                image: 'Chevalier Ep√©e Rouill√©e.png',
                description: '"Don Quitousse" est un tr√®s vieux chevalier √† la retraite. Il est assez √©puis√© par une vie de qu√™tes √† travers le monde et n\'entretient plus tr√®s bien son noble outil. La rouille s\'est peu √† peu d√©pos√©e sur le tranchant √©mouss√© de sa fid√®le protectrice mais jamais il ne la quittera pour une autre. Il dort encore tous les soirs avec elle ces temps-ci : gare aux importuns ! Si le Chevalier est d√©vor√©, il est √©limin√©, mais un des Loups-Garous est contamin√© par l\'√©p√©e rouill√©e. Parmi les Loups-Garous coupables de cette √©limination, le premier Loup-Garou situ√© √† gauche du Chevalier √† l\'√âp√©e Rouill√©e sera √©limin√© au d√©but de la nuit suivante. Cette √©limination due √† la maladie provoqu√©e par la rouille sera r√©v√©l√©e par le meneur le matin suivant la disparition du Loup-Garou. Celui-ci aura donc surv√©cu √† sa blessure durant une journ√©e.'
            },
            'Ancien': {
                image: 'Ancien.png',
                description: 'Il a victorieusement travers√© toutes les terribles √©preuves de la vie, et a acquis une r√©sistance hors du commun ! Les Loups-Garous devront s\'y prendre √† 2 fois pour le d√©vorer. La premi√®re fois que l\'Ancien du village est d√©vor√© par les Loups-Garous, il survit ; le meneur de jeu ne retourne pas sa carte. L\'Ancien est √©limin√© seulement la deuxi√®me fois qu\'il est d√©vor√©. Le vote du village, la potion d\'empoisonnement de la Sorci√®re et le tir du Chasseur √©liminent l\'Ancien du premier coup. Mais, d√©sesp√©r√©s d\'avoir √©limin√© par erreur un tel puits de sciences, les villageois perdent leurs pouvoirs sp√©ciaux jusqu\'√† la fin de la partie. Attention : si l\'Ancien du village se fait soigner par la Sorci√®re, il r√©cup√®re une seule vie. Si son amour est √©limin√©, l\'Ancien meurt imm√©diatement de chagrin, mais les pouvoirs sp√©ciaux des villageois ne sont pas perdus. Il n\'est pas affect√© par l\'Infect P√®re des Loups.'
            },
            'Montreur Ours': {
                image: 'Montreur Ours.png',
                description: 'Chaque matin, juste apr√®s la r√©v√©lation des √©ventuelles victimes nocturnes, si au moins un Loup-Garou est, ou devient un des deux voisins du Montreur d\'Ours, alors le meneur grogne pour signifier aux joueurs que l\'ours du Montreur a senti le danger. Seuls les voisins toujours en jeu sont pris en compte. Conseil au meneur : pour faciliter les choses, les joueurs √©limin√©s sortent de la partie, ou s\'√©cartent de la table. Si le Montreur d\'Ours est infect√©, alors le meneur grogne tous les tours, tant que le Montreur d\'Ours n\'est pas √©limin√©.'
            },
            'Chein Loup': {
                image: 'Chein Loup.png',
                description: 'Tous les chiens savent au tr√©fonds d\'eux-m√™mes que leurs anc√™tres √©taient loups et que c\'est l\'Homme qui les a maintenus dans cet √©tat de compagnons enfantins et craintifs, mais fid√®les et g√©n√©reux. En tout cas, seul le Chien-Loup peut d√©cider s\'il ob√©ira √† son ma√Ætre humain et civilis√© ou s\'il √©coutera l\'appel de la nature sauvage enfouie dans ses entrailles. La premi√®re nuit, le Chien-Loup choisit s\'il d√©sire √™tre villageois ou rejoindre les Loups-Garous. Ce choix est d√©finitif ! S\'il d√©sire √™tre Loup-Garou, il se r√©veillera avec eux toutes les nuits pour d√©vorer une victime. S\'il choisit de rester villageois, il gardera les yeux clos durant les nuits et participera aux d√©bats et votes des villageois le jour pour tenter d\'√©liminer les Loups-Garous.'
            },
            'Loup Garou Blanc': {
                image: 'Loup Garou Blanc.png',
                description: 'Ce tr√®s malfaisant personnage d√©teste autant les Loups-Garous que les villageois ! On raconte qu\'une √©trange mutation serait survenue au sein m√™me de la population lycanthropique. Chaque nuit, il se r√©veille et d√©vore avec les autres Loups-Garous. Mais une nuit sur deux, √† l\'appel du meneur, il se r√©veille seul et peut √©liminer un Loup-Garou. Le but de ce personnage est de rester le seul survivant du village. Dans ce cas-l√† seulement il gagne la partie.'
            },
            'Sorci√®re': {
                image: 'Sorci√®re.png',
                description: 'Elle sait concocter deux potions extr√™mement puissantes : une potion de gu√©rison, pour ressusciter le joueur d√©vor√© par les Loups-Garous et une potion d\'empoisonnement, utilis√©e la nuit pour √©liminer un joueur de son choix. Chaque nuit, le meneur r√©veille la Sorci√®re. Il lui montre la victime des Loups-Garous puis lui propose d\'utiliser chacune de ses potions, tant qu\'elles sont disponibles. La Sorci√®re peut utiliser chaque potion 1 seule fois dans la partie. Elle peut se servir de ses 2 potions la m√™me nuit. La Sorci√®re peut √©galement utiliser la potion de gu√©rison √† son profit, et donc se gu√©rir elle-m√™me si elle vient d\'√™tre d√©vor√©e par les Loups-Garous. Sa potion de gu√©rison ne d√©livre pas de la contamination due √† l\'Infect P√®re des Loups.'
            },
            'Enfant Sauvage': {
                image: 'Enfant Sauvage.png',
                description: 'Abandonn√© dans la for√™t par ses parents dans sa plus tendre enfance, il y fut √©lev√© par des loups. D√®s qu\'il sut marcher √† quatre pattes, l\'Enfant Sauvage se mit √† errer aux abords de Thiercelieux. Un beau jour, fascin√© par un habitant du village qui marchait debout avec gr√¢ce et prestance, il en fit son mod√®le en secret. Il d√©cida alors d\'int√©grer la communaut√© de Thiercelieux et p√©n√©tra, inquiet, dans le village. L\'Enfant Sauvage est un villageois. La premi√®re nuit, √† l\'appel du meneur, il d√©signe un joueur mod√®le. Si durant la partie le joueur d√©sign√© est √©limin√©, l\'Enfant Sauvage devient Loup-Garou. Il se r√©veillera d√®s la nuit suivante avec ses cong√©n√®res et d√©vorera avec eux toutes les nuits jusqu\'√† la fin de la partie. En revanche, tant que son mod√®le est vivant, l\'Enfant Sauvage demeure un villageois. Que son mod√®le s\'av√®re ou non √™tre un Loup-Garou ne change rien √† l\'affaire ! Il partagera l\'√©ventuelle victoire des Loups-Garous si son mod√®le a √©t√© √©limin√©. Il partagera l\'√©ventuelle victoire des villageois si son mod√®le est toujours en vie.'
            },
            'Joueur de Fl√ªte': {
                image: 'Joueur Fl√ªte.png',
                description: 'Ignominieusement chass√© du village, il est revenu des ann√©es plus tard sous le couvert d\'une fausse identit√© pour exercer sa terrible vengeance. Le but du Joueur de Fl√ªte est de charmer tous les habitants du village. Chaque nuit √† l\'appel du meneur, le Joueur de Fl√ªte d√©signe 2 nouveaux joueurs dont le meneur touche l\'√©paule. Le Joueur de Fl√ªte se rendort. Le meneur demande aux nouveaux et anciens charm√©s de se r√©veiller. Ils se reconnaissent et se rendorment. D√®s l\'instant o√π il ne reste plus que des joueurs charm√©s, le Joueur de Fl√ªte a gagn√© contre tous les autres (m√™me si cela arrive suite √† un vote du village, au tir du Chasseur, gr√¢ce aux Loups-Garous, etc). Attention : s\'il est infect√© par l\'Infect P√®re des Loups, il devient un simple Loup-Garou. Son objectif initial, qui √©tait de vouloir charmer tous les joueurs, est donc abandonn√©.'
            },
            'Ange': {
                image: 'Ange.png',
                description: 'La vie fangeuse d\'un village infest√© de cr√©atures malfaisantes le d√©go√ªte ; il souhaite se r√©veiller de ce qu\'il croit √™tre un cauchemar, enfin paisible, dans son lit douillet. Quand l\'Ange est en jeu, la partie d√©bute toujours par le d√©bat du village suivi d\'un vote √©liminatoire, puis d\'une premi√®re nuit. Si l\'Ange r√©ussit √† attirer le vote discriminatoire des villageois, la vindicte d√©vorante des lycanthropes ou la potion d\'empoisonnement de la Sorci√®re, donc s\'il est √©limin√© au premier tour, il sort vainqueur du cauchemar et gagne la partie. Alors le jeu s\'arr√™te : les joueurs peuvent commencer imm√©diatement une nouvelle partie. S\'il √©choue, il deviendra Simple Villageois pour la suite de la partie. Attention : si l\'Ange tombe amoureux, il d√©laisse son pr√©c√©dent objectif et tente de survivre avec son partenaire.'
            }
        };

        // Rendre le contenu d'aide aux r√¥les
        function renderRoleHelp(containerElement) {
            const container = containerElement || document.getElementById('roleHelpContent');
            container.innerHTML = '';
            
            // R√¥les de base
            const baseRoles = [
                { name: 'Simple Villageois', icon: 'üë§' },
                { name: 'Cupidon', icon: 'üíò' },
                { name: 'Voyante', icon: 'üîÆ' },
                { name: 'Petite Fille', icon: 'üëß' },
                { name: 'Deux Soeurs', icon: 'üëØ' },
                { name: 'Chasseur', icon: 'üèπ' },
                { name: 'Simple Loups-garous', icon: 'üê∫' },
                { name: 'Sorci√®re', icon: 'üß™' }
            ];
            
            // R√¥les d'extension
            const extensionRoles = [
                { name: 'Infect P√®re des Loups', icon: 'üßõ' },
                { name: 'Le Grand M√©chant Loup', icon: 'üê∫üí™' },
                { name: 'Renard', icon: 'ü¶ä' },
                { name: 'Chevalier Ep√©e Rouill√©e', icon: '‚öîÔ∏èüõ°Ô∏è' },
                { name: 'Ancien', icon: 'üë¥' },
                { name: 'Montreur Ours', icon: 'üêª' },
                { name: 'Chein Loup', icon: 'üêïüê∫' },
                { name: 'Loup Garou Blanc', icon: 'üåô' },
                { name: 'Enfant Sauvage', icon: 'üåø' },
                { name: 'Joueur de Fl√ªte', icon: 'üéµ' },
                { name: 'Ange', icon: 'üëº' }
            ];
            
            // Cr√©er une section pour les r√¥les de base
            const baseSection = document.createElement('div');
            baseSection.className = 'help-section';
            const baseTitle = document.createElement('h2');
            baseTitle.className = 'help-section-title';
            baseTitle.textContent = 'üé≠ R√¥les de Base';
            baseTitle.style.color = '#333';
            baseTitle.style.marginBottom = '20px';
            baseTitle.style.fontSize = '2rem';
            baseSection.appendChild(baseTitle);
            
            const baseGrid = document.createElement('div');
            baseGrid.className = 'role-help-content';
            baseRoles.forEach(role => {
                const desc = roleDescriptions[role.name];
                if (desc) {
                    createRoleHelpCard(baseGrid, role.name, desc.image, desc.description, role.icon);
                }
            });
            baseSection.appendChild(baseGrid);
            container.appendChild(baseSection);
            
            // Cr√©er une section pour les r√¥les d'extension
            const extSection = document.createElement('div');
            extSection.className = 'help-section';
            extSection.style.marginTop = '50px';
            const extTitle = document.createElement('h2');
            extTitle.className = 'help-section-title';
            extTitle.textContent = 'üì¶ R√¥les d\'Extension';
            extTitle.style.color = '#333';
            extTitle.style.marginBottom = '20px';
            extTitle.style.fontSize = '2rem';
            extSection.appendChild(extTitle);
            
            const extGrid = document.createElement('div');
            extGrid.className = 'role-help-content';
            extensionRoles.forEach(role => {
                const desc = roleDescriptions[role.name];
                if (desc) {
                    createRoleHelpCard(extGrid, role.name, desc.image, desc.description, role.icon);
                }
            });
            extSection.appendChild(extGrid);
            container.appendChild(extSection);
        }

        // Afficher la page d'aide
        function showHelpPage() {
            const helpPage = document.getElementById('helpPage');
            const container = document.getElementById('helpPageContent');
            const helpBtn = document.getElementById('roleHelpBtnInMenu');
            
            helpPage.style.display = 'block';
            document.body.classList.add('help-mode');
            
            // Masquer le bouton aide dans le menu
            if (helpBtn) helpBtn.style.display = 'none';
            
            // G√©n√©rer le contenu (toujours recr√©er pour mettre √† jour les pr√©noms)
            renderRoleHelp(container);
            
            // Scroll en haut
            helpPage.scrollTop = 0;
        }

        // Masquer la page d'aide
        function hideHelpPage() {
            const helpPage = document.getElementById('helpPage');
            const helpBtn = document.getElementById('roleHelpBtnInMenu');
            
            helpPage.style.display = 'none';
            document.body.classList.remove('help-mode');
            
            // Afficher le bouton aide dans le menu
            if (helpBtn) helpBtn.style.display = 'block';
        }

        // Recharger la page avec le menu burger ouvert et sur la page prompteur
        function reloadWithMenuOpen() {
            // Stocker un flag dans sessionStorage pour indiquer qu'on doit ouvrir le menu
            sessionStorage.setItem('reloadWithMenuOpen', 'true');
            // S'assurer qu'on est sur la page prompteur (pas la page d'aide)
            sessionStorage.setItem('showPrompteurPage', 'true');
            // Recharger la page
            window.location.reload();
        }


        // Cr√©er une carte d'aide pour un r√¥le
        function createRoleHelpCard(container, roleName, imagePath, description, icon) {
            const card = document.createElement('div');
            card.className = 'role-help-card';
            
            // Conteneur pour l'image avec gestion du pr√©nom
            const imageContainer = document.createElement('div');
            imageContainer.className = 'role-image-container';
            imageContainer.style.position = 'relative';
            imageContainer.style.cursor = 'pointer';
            
            const img = document.createElement('img');
            img.src = imagePath;
            img.alt = roleName;
            img.className = 'role-help-card-image';
            img.onerror = function() {
                this.style.display = 'none';
                const iconDiv = document.createElement('div');
                iconDiv.style.fontSize = '4rem';
                iconDiv.style.marginBottom = '15px';
                iconDiv.textContent = icon;
                imageContainer.appendChild(iconDiv);
            };
            
            imageContainer.appendChild(img);
            
            // Input pour saisir le pr√©nom (cach√© par d√©faut)
            const inputContainer = document.createElement('div');
            inputContainer.className = 'role-name-input-container';
            inputContainer.style.cssText = 'display: none; margin-top: 10px; width: 100%;';
            
            const inputGroup = document.createElement('div');
            inputGroup.style.cssText = 'display: flex; gap: 5px; align-items: center; justify-content: center;';
            
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.placeholder = 'Entrez le pr√©nom';
            nameInput.className = 'role-name-input';
            nameInput.style.cssText = 'flex: 1; padding: 8px 12px; border: 2px solid rgba(37, 150, 190, 0.5); border-radius: 8px; font-size: 0.9rem; color: #333; background: white; max-width: 200px;';
            
            const saveBtn = document.createElement('button');
            saveBtn.textContent = '‚úì';
            saveBtn.className = 'role-name-save-btn';
            saveBtn.style.cssText = 'padding: 8px 15px; background: rgba(37, 150, 190, 0.9); color: white; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; font-weight: bold; transition: all 0.3s;';
            saveBtn.onmouseenter = function() {
                this.style.background = 'rgba(37, 150, 190, 1)';
                this.style.transform = 'scale(1.1)';
            };
            saveBtn.onmouseleave = function() {
                this.style.background = 'rgba(37, 150, 190, 0.9)';
                this.style.transform = 'scale(1)';
            };
            
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = '‚úï';
            cancelBtn.className = 'role-name-cancel-btn';
            cancelBtn.style.cssText = 'padding: 8px 15px; background: rgba(200, 200, 200, 0.9); color: #333; border: none; border-radius: 8px; font-size: 1rem; cursor: pointer; font-weight: bold; transition: all 0.3s;';
            cancelBtn.onmouseenter = function() {
                this.style.background = 'rgba(200, 200, 200, 1)';
                this.style.transform = 'scale(1.1)';
            };
            cancelBtn.onmouseleave = function() {
                this.style.background = 'rgba(200, 200, 200, 0.9)';
                this.style.transform = 'scale(1)';
            };
            
            inputGroup.appendChild(nameInput);
            inputGroup.appendChild(saveBtn);
            inputGroup.appendChild(cancelBtn);
            inputContainer.appendChild(inputGroup);
            
            // Cr√©er le titre d'abord
            const title = document.createElement('h3');
            title.className = 'role-help-card-title';
            const updateTitle = function() {
                // Ne pas afficher les pr√©noms dans la page d'aide aux r√¥les (visible par tous les joueurs)
                title.textContent = `${icon} ${roleName}`;
            };
            updateTitle();
            
            
            // Fonction pour masquer l'input
            const hideInput = function() {
                inputContainer.style.display = 'none';
                nameInput.value = '';
            };
            
            // Fonction pour afficher l'input
            const showInput = function() {
                inputContainer.style.display = 'block';
                nameInput.value = ''; // Toujours vide pour ajouter un nouveau pr√©nom
                nameInput.focus();
                // Scroll jusqu'√† l'input si n√©cessaire
                inputContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            };
            
            // Gestion du clic sur l'image pour afficher l'input
            imageContainer.onclick = function(e) {
                e.stopPropagation();
                // Fermer tous les autres inputs ouverts
                document.querySelectorAll('.role-name-input-container').forEach(el => {
                    if (el !== inputContainer && el.style.display !== 'none') {
                        el.style.display = 'none';
                    }
                });
                showInput();
            };
            
            // Gestion de la sauvegarde
            const saveFirstName = function() {
                const firstName = nameInput.value.trim();
                if (firstName) {
                    addRoleFirstName(roleName, firstName);
                    updateTitle();
                    hideInput();
                    showToast('‚úÖ Envoy√© au ma√Ætre du jeu');
                }
            };
            
            saveBtn.onclick = function(e) {
                e.stopPropagation();
                saveFirstName();
            };
            
            cancelBtn.onclick = function(e) {
                e.stopPropagation();
                hideInput();
            };
            
            // Sauvegarde avec Entr√©e
            nameInput.onkeydown = function(e) {
                if (e.key === 'Enter') {
                    e.stopPropagation();
                    saveFirstName();
                } else if (e.key === 'Escape') {
                    e.stopPropagation();
                    hideInput();
                }
            };
            
            // Stocker la fonction hideInput dans l'inputContainer pour la r√©cup√©rer plus tard
            inputContainer.hideInputFn = hideInput;
            inputContainer.imageContainer = imageContainer;
            
            const desc = document.createElement('div');
            desc.className = 'role-help-card-description';
            desc.textContent = description;
            
            card.appendChild(imageContainer);
            card.appendChild(inputContainer);
            card.appendChild(title);
            card.appendChild(desc);
            
            container.appendChild(card);
        }

        // Syst√®me de toaster
        function showToast(message) {
            // Supprimer les toasters existants
            const existingToasts = document.querySelectorAll('.toast');
            existingToasts.forEach(toast => toast.remove());
            
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            toast.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(37, 150, 190, 0.95);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
                z-index: 10000;
                font-size: 1rem;
                font-weight: bold;
                animation: slideInRight 0.3s ease, fadeOut 0.3s ease 2.7s;
                pointer-events: none;
            `;
            
            // Ajouter les animations CSS si elles n'existent pas
            if (!document.getElementById('toast-animations')) {
                const style = document.createElement('style');
                style.id = 'toast-animations';
                style.textContent = `
                    @keyframes slideInRight {
                        from {
                            transform: translateX(100%);
                            opacity: 0;
                        }
                        to {
                            transform: translateX(0);
                            opacity: 1;
                        }
                    }
                    @keyframes fadeOut {
                        from {
                            opacity: 1;
                        }
                        to {
                            opacity: 0;
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            document.body.appendChild(toast);
            
            // Supprimer apr√®s 3 secondes
            setTimeout(() => {
                toast.style.animation = 'fadeOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 2700);
        }

        // Event listener global pour fermer les inputs quand on clique ailleurs (ajout√© une seule fois au chargement)
        (function() {
            document.addEventListener('click', function(e) {
                // Fermer tous les inputs ouverts sauf si on clique sur l'input ou l'image
                const allInputContainers = document.querySelectorAll('.role-name-input-container');
                allInputContainers.forEach(inputContainer => {
                    if (inputContainer.style.display !== 'none' && 
                        !inputContainer.contains(e.target) && 
                        inputContainer.imageContainer && 
                        !inputContainer.imageContainer.contains(e.target)) {
                        if (inputContainer.hideInputFn) {
                            inputContainer.hideInputFn();
                        }
                    }
                });
            }, true);
        })();

        const prompteur = document.getElementById('prompteur');
        const prompteurTitle = document.getElementById('prompteurTitle');
        const prompteurText = document.getElementById('prompteurText');
        const phaseInfo = document.getElementById('phaseInfo');
        const startBtn = document.getElementById('startBtn');
        const nextBtn = document.getElementById('nextBtn');
        const phaseSelector = document.getElementById('phaseSelector');

        // Fonction pour l'effet typewriter avec support HTML
        function typeText(element, text, speed = 30) {
            // Annuler l'animation en cours
            if (typewriterTimeout) {
                clearTimeout(typewriterTimeout);
            }
            isTyping = true;
            
            // Extraire le texte brut pour compter les caract√®res
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            const plainText = tempDiv.textContent || tempDiv.innerText || '';
            
            // Parser le HTML en tokens (balises et texte)
            const tokens = [];
            let inTag = false;
            let currentTag = '';
            let currentText = '';
            
            for (let i = 0; i < text.length; i++) {
                if (text[i] === '<') {
                    if (currentText) {
                        tokens.push({ type: 'text', content: currentText });
                        currentText = '';
                    }
                    inTag = true;
                    currentTag = '<';
                } else if (text[i] === '>') {
                    currentTag += '>';
                    tokens.push({ type: 'tag', content: currentTag });
                    currentTag = '';
                    inTag = false;
                } else {
                    if (inTag) {
                        currentTag += text[i];
                    } else {
                        currentText += text[i];
                    }
                }
            }
            if (currentText) {
                tokens.push({ type: 'text', content: currentText });
            }
            
            // Animer les tokens
            let tokenIndex = 0;
            let charIndex = 0;
            let currentHTML = '';
            
            function typeChar() {
                if (tokenIndex < tokens.length) {
                    const token = tokens[tokenIndex];
                    
                    if (token.type === 'tag') {
                        // Afficher la balise compl√®te
                        currentHTML += token.content;
                        element.innerHTML = currentHTML + '<span class="typing-cursor"></span>';
                        tokenIndex++;
                        typewriterTimeout = setTimeout(typeChar, speed * 2);
                    } else {
                        // Afficher caract√®re par caract√®re
                        if (charIndex < token.content.length) {
                            const char = token.content[charIndex];
                            // √âchapper pour s√©curit√©
                            const div = document.createElement('div');
                            div.textContent = char;
                            currentHTML += div.innerHTML;
                            // Afficher le HTML actuel avec UN SEUL curseur √† la fin
                            element.innerHTML = currentHTML + '<span class="typing-cursor"></span>';
                            charIndex++;
                            typewriterTimeout = setTimeout(typeChar, speed);
                        } else {
                            tokenIndex++;
                            charIndex = 0;
                            typewriterTimeout = setTimeout(typeChar, 10);
                        }
                    }
                } else {
                    // Animation termin√©e - retirer le curseur et afficher le texte complet
                    element.innerHTML = text;
                    isTyping = false;
                    typewriterTimeout = null;
                }
            }
            
            // Commencer avec un contenu vide
            element.innerHTML = '';
            typeChar();
        }

        // Fonction pour arr√™ter l'animation en cours
        function stopTyping() {
            if (typewriterTimeout) {
                clearTimeout(typewriterTimeout);
                typewriterTimeout = null;
            }
            isTyping = false;
            // Retirer le curseur s'il est pr√©sent
            const cursors = prompteurText.querySelectorAll('.typing-cursor');
            cursors.forEach(cursor => cursor.remove());
        }

        // Initialisation
        // Fonction pour jouer le hurlement du loup
        function playWolfHowl() {
            const audio = document.getElementById('wolfHowlAudio');
            if (audio) {
                // Remettre le son au d√©but pour pouvoir le rejouer imm√©diatement
                audio.currentTime = 0;
                audio.play().catch(error => {
                    console.error('Erreur lors de la lecture du son:', error);
                    // En cas d'erreur (par exemple si l'utilisateur n'a pas encore interagi avec la page),
                    // on peut essayer de recharger la source audio
                    audio.load();
                    audio.play().catch(err => {
                        console.error('Impossible de jouer le son:', err);
                    });
                });
            }
        }

        function init() {
            renderRoleSelector();
            renderEliminationList();
            renderNamesManagement();
            generatePhases();
            renderPhaseSelector();
            initializeContentStructure();
            updateDisplay();
            
            // V√©rifier si on doit ouvrir le menu burger apr√®s rechargement
            const reloadWithMenu = sessionStorage.getItem('reloadWithMenuOpen');
            const showPrompteur = sessionStorage.getItem('showPrompteurPage');
            
            if (reloadWithMenu === 'true') {
                // Si on recharge avec le menu ouvert, afficher le prompteur (pas la page d'aide)
                if (showPrompteur === 'true') {
                    hideHelpPage();
                }
                // Nettoyer le flag
                sessionStorage.removeItem('reloadWithMenuOpen');
                sessionStorage.removeItem('showPrompteurPage');
                
                // Ouvrir le menu burger apr√®s un court d√©lai pour que le DOM soit pr√™t
                setTimeout(() => {
                    const panel = document.getElementById('roleSelectorPanel');
                    const overlay = document.getElementById('menuOverlay');
                    const burgerBtn = document.getElementById('burgerMenuBtn');
                    const helpBurgerBtn = document.getElementById('helpBurgerMenuBtn');
                    
                    if (panel && overlay) {
                        // Ouvrir le menu sans demander le code (on vient de recharger depuis le menu)
                        panel.classList.add('active');
                        overlay.classList.add('active');
                        if (burgerBtn) burgerBtn.classList.add('active');
                        if (helpBurgerBtn) helpBurgerBtn.classList.add('active');
                    }
                }, 100);
            } else {
                // Comportement par d√©faut : afficher la page d'aide
                showHelpPage();
            }
            
            // Ajouter les event listeners pour la confirmation de r√©initialisation
            const confirmResetBtn = document.getElementById('confirmResetBtn');
            const cancelResetBtn = document.getElementById('cancelResetBtn');
            if (confirmResetBtn) {
                confirmResetBtn.addEventListener('click', resetRoleNames);
            }
            if (cancelResetBtn) {
                cancelResetBtn.addEventListener('click', hideResetConfirmation);
            }
            
            // √âcouter le redimensionnement de la fen√™tre pour r√©ajuster la taille du texte
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    adjustTextSize();
                }, 150);
            });
        }

        // Rendre le s√©lecteur de phases
        function renderPhaseSelector() {
            phaseSelector.innerHTML = '';
            phases.forEach((phase, index) => {
                const btn = document.createElement('button');
                btn.className = 'phase-btn';
                btn.textContent = phase.title;
                btn.onclick = () => goToPhase(index);
                phaseSelector.appendChild(btn);
            });
        }

        // Initialiser la structure DOM une seule fois
        function initializeContentStructure() {
            // Vider le conteneur
            prompteurText.innerHTML = '';
            
            // Cr√©er la structure de base
            const descriptionDiv = document.createElement('div');
            descriptionDiv.className = 'phase-description';
            
            const actionsList = document.createElement('ul');
            actionsList.className = 'phase-actions';
            
            prompteurText.appendChild(descriptionDiv);
            prompteurText.appendChild(actionsList);
        }

        // Mettre √† jour uniquement les classes des actions (changement d'action sans changer de phase)
        function updateActionHighlight() {
            const phase = phases[currentPhaseIndex];
            if (!phase.actions || phase.actions.length === 0) return;
            
            const actionsList = prompteurText.querySelector('.phase-actions');
            if (!actionsList) return;
            
            const allItems = actionsList.querySelectorAll('li');
            
            allItems.forEach((item, index) => {
                // Retirer toutes les classes
                item.classList.remove('active-action', 'completed-action');
                
                // Ajouter les classes appropri√©es
                if (index < currentActionIndex) {
                    item.classList.add('completed-action');
                } else if (index === currentActionIndex) {
                    item.classList.add('active-action');
                }
            });
        }

        // Ajuster automatiquement la taille du texte pour √©viter les scrollbars
        function adjustTextSize() {
            // Attendre un court d√©lai pour que le DOM se mette √† jour
            setTimeout(() => {
                // R√©initialiser toutes les tailles pour repartir de z√©ro
                prompteurText.style.fontSize = '';
                prompteurText.style.lineHeight = '';
                
                // R√©cup√©rer tous les √©l√©ments
                const descriptionDiv = prompteurText.querySelector('.phase-description');
                const actionsList = prompteurText.querySelector('.phase-actions');
                const listItems = actionsList ? actionsList.querySelectorAll('li') : [];
                
                if (descriptionDiv) {
                    descriptionDiv.style.fontSize = '';
                    descriptionDiv.style.lineHeight = '';
                    descriptionDiv.style.marginBottom = '';
                }
                
                listItems.forEach(li => {
                    li.style.fontSize = '';
                    li.style.lineHeight = '';
                    li.style.padding = '';
                    li.style.margin = '';
                });
                
                // Attendre un frame pour que les styles par d√©faut soient appliqu√©s
                requestAnimationFrame(() => {
                    // Forcer un recalcul du layout pour prendre en compte les classes CSS appliqu√©es (active-action, completed-action)
                    void prompteurText.offsetHeight;
                    
                    // Calculer la hauteur disponible r√©elle (utiliser le max-height du CSS)
                    const computedStyle = window.getComputedStyle(prompteurText);
                    // R√©cup√©rer le max-height calcul√© depuis le CSS (85vh par d√©faut, adapt√© en responsive)
                    const maxHeightValue = computedStyle.maxHeight;
                    const maxHeightPx = maxHeightValue === 'none' 
                        ? window.innerHeight * 0.85 
                        : parseFloat(maxHeightValue) || window.innerHeight * 0.85;
                    const paddingTop = parseFloat(computedStyle.paddingTop) || 10;
                    const paddingBottom = parseFloat(computedStyle.paddingBottom) || 10;
                    const availableHeight = maxHeightPx - paddingTop - paddingBottom;
                    
                    // Taille de base
                    const baseFontSize = 1.8;
                    const minFontSize = 0.35; // Taille minimum encore plus r√©duite
                    let newFontSize = baseFontSize;
                    
                    // Fonction pour appliquer les tailles et v√©rifier
                    const applySizesAndCheck = (fontSize) => {
                        newFontSize = fontSize;
                        const sizeRatio = newFontSize / baseFontSize;
                        
                        // Appliquer au conteneur principal avec r√©duction du line-height
                        prompteurText.style.fontSize = newFontSize + 'rem';
                        prompteurText.style.lineHeight = (1.6 * sizeRatio) + 'rem';
                        
                        // Ajuster la description
                        if (descriptionDiv) {
                            const descBaseSize = 1.6;
                            descriptionDiv.style.fontSize = (descBaseSize * sizeRatio) + 'rem';
                            descriptionDiv.style.lineHeight = (1.5 * sizeRatio) + 'rem';
                            descriptionDiv.style.marginBottom = (15 * sizeRatio) + 'px';
                        }
                        
                        // Ajuster les li avec r√©duction agressive des espacements
                        listItems.forEach(li => {
                            const liBaseSize = 1.6;
                            li.style.fontSize = (liBaseSize * sizeRatio) + 'rem';
                            
                            // R√©duire agressivement line-height, padding et margin
                            const aggressiveRatio = Math.max(sizeRatio * 0.75, 0.4); // R√©duction encore plus agressive
                            li.style.lineHeight = '1.2'; // Line-height fixe et tr√®s compact
                            li.style.paddingTop = Math.max(4 * aggressiveRatio, 2) + 'px';
                            li.style.paddingBottom = Math.max(4 * aggressiveRatio, 2) + 'px';
                            li.style.paddingLeft = Math.max(15 * sizeRatio, 10) + 'px';
                            li.style.paddingRight = Math.max(15 * sizeRatio, 10) + 'px';
                            li.style.marginTop = Math.max(2 * aggressiveRatio, 1) + 'px';
                            li.style.marginBottom = Math.max(2 * aggressiveRatio, 1) + 'px';
                        });
                        
                        // Forcer un recalcul du layout
                        void prompteurText.offsetHeight;
                        const scrollHeight = prompteurText.scrollHeight;
                        return scrollHeight;
                    };
                    
                    // It√©rer pour trouver la bonne taille (m√©thode binaire pour plus d'efficacit√©)
                    let low = minFontSize;
                    let high = baseFontSize;
                    let bestSize = baseFontSize;
                    let iterations = 0;
                    const maxIterations = 15;
                    
                    while (iterations < maxIterations && (high - low) > 0.05) {
                        iterations++;
                        const mid = (low + high) / 2;
                        const scrollHeight = applySizesAndCheck(mid);
                        
                        if (scrollHeight <= availableHeight) {
                            // √áa rentre, on peut essayer plus grand
                            bestSize = mid;
                            low = mid;
                        } else {
                            // √áa d√©passe, il faut r√©duire
                            high = mid;
                        }
                    }
                    
                    // Appliquer la meilleure taille trouv√©e
                    let finalScrollHeight = applySizesAndCheck(bestSize);
                    
                    // Si √ßa d√©passe encore, appliquer des r√©glages ultra-compacts
                    let attempts = 0;
                    const maxAttempts = 5;
                    while (finalScrollHeight > availableHeight && attempts < maxAttempts) {
                        attempts++;
                        // R√©duire encore plus agressivement
                        newFontSize = Math.max(minFontSize, newFontSize * 0.85);
                        finalScrollHeight = applySizesAndCheck(newFontSize);
                        
                        // R√©duire encore plus les espacements progressivement
                        const ultraCompactRatio = 1 - (attempts * 0.15); // R√©duction progressive
                        listItems.forEach(li => {
                            const currentPadding = parseFloat(li.style.paddingTop) || 4;
                            const currentMargin = parseFloat(li.style.marginTop) || 2;
                            li.style.paddingTop = Math.max(currentPadding * ultraCompactRatio, 1) + 'px';
                            li.style.paddingBottom = Math.max(currentPadding * ultraCompactRatio, 1) + 'px';
                            li.style.marginTop = Math.max(currentMargin * ultraCompactRatio, 0.5) + 'px';
                            li.style.marginBottom = Math.max(currentMargin * ultraCompactRatio, 0.5) + 'px';
                            li.style.lineHeight = Math.max(1.1, 1.3 - (attempts * 0.05)).toString();
                        });
                        
                        if (descriptionDiv) {
                            descriptionDiv.style.marginBottom = Math.max(5, 15 * ultraCompactRatio) + 'px';
                        }
                        
                        // Forcer un recalcul
                        void prompteurText.offsetHeight;
                        finalScrollHeight = prompteurText.scrollHeight;
                    }
                    
                    // Si √ßa d√©passe encore apr√®s tous les ajustements, r√©duire la taille de police jusqu'√† ce que √ßa rentre
                    let finalAttempts = 0;
                    while (finalScrollHeight > availableHeight && newFontSize > minFontSize && finalAttempts < 10) {
                        finalAttempts++;
                        newFontSize = Math.max(minFontSize, newFontSize - 0.03);
                        finalScrollHeight = applySizesAndCheck(newFontSize);
                        
                        // R√©duire encore plus les espacements en dernier recours
                        if (finalScrollHeight > availableHeight) {
                            listItems.forEach(li => {
                                li.style.paddingTop = '1px';
                                li.style.paddingBottom = '1px';
                                li.style.marginTop = '0.5px';
                                li.style.marginBottom = '0.5px';
                                li.style.lineHeight = '1.1';
                            });
                            void prompteurText.offsetHeight;
                            finalScrollHeight = prompteurText.scrollHeight;
                        }
                    }
                });
            }, 100);
        }

        // Mettre √† jour le contenu d'une phase
        function updatePhaseContent() {
            const phase = phases[currentPhaseIndex];
            
            // R√©cup√©rer ou cr√©er les √©l√©ments
            let descriptionDiv = prompteurText.querySelector('.phase-description');
            let actionsList = prompteurText.querySelector('.phase-actions');
            
            // Si la structure n'existe pas, l'initialiser
            if (!descriptionDiv || !actionsList) {
                initializeContentStructure();
                descriptionDiv = prompteurText.querySelector('.phase-description');
                actionsList = prompteurText.querySelector('.phase-actions');
            }
            
            // Mettre √† jour la description
            descriptionDiv.textContent = phase.text;
            
            // Mettre √† jour la liste d'actions
            if (phase.actions && phase.actions.length > 0) {
                // Vider la liste
                actionsList.innerHTML = '';
                
                // Cr√©er les √©l√©ments li
                phase.actions.forEach((action, index) => {
                    const li = document.createElement('li');
                    li.textContent = action;
                    
                    // Ajouter les classes appropri√©es
                    if (index < currentActionIndex) {
                        li.classList.add('completed-action');
                    } else if (index === currentActionIndex) {
                        li.classList.add('active-action');
                    }
                    
                    actionsList.appendChild(li);
                });
                
                // Afficher la liste
                actionsList.style.display = '';
                descriptionDiv.style.display = '';
                
                // Ajuster la taille du texte apr√®s un court d√©lai pour laisser le DOM se mettre √† jour
                setTimeout(() => {
                    adjustTextSize();
                }, 150);
            } else {
                // Pas d'actions, masquer la liste et afficher seulement la description
                actionsList.style.display = 'none';
                descriptionDiv.style.display = '';
                
                // Ajuster la taille du texte
                setTimeout(() => {
                    adjustTextSize();
                }, 50);
            }
        }

        // Mettre √† jour l'affichage
        function updateDisplay() {
            const phase = phases[currentPhaseIndex];
            
            // Arr√™ter l'animation en cours
            stopTyping();
            
            // Mettre √† jour les informations de phase
            phaseInfo.textContent = `Phase ${currentPhaseIndex + 1}/${phases.length} - ${phase.title}`;
            
            // Mettre √† jour le titre (sans animation pour le titre)
            prompteurTitle.textContent = phase.title;
            
            // Si on change de phase, mettre √† jour le contenu
            if (displayedPhaseIndex !== currentPhaseIndex) {
                displayedPhaseIndex = currentPhaseIndex;
                updatePhaseContent();
            } else {
                // M√™me phase, juste mettre √† jour les classes CSS sans redimensionnement
                updateActionHighlight();
            }
            
            // Mettre √† jour les boutons
            updateButtons();
            updatePhaseButtons();
        }

        // Mettre √† jour les boutons de navigation
        function updateButtons() {
            startBtn.style.display = currentPhaseIndex === 0 ? 'block' : 'none';
            nextBtn.style.display = currentPhaseIndex > 0 ? 'block' : 'none';
            
            const phase = phases[currentPhaseIndex];
            const hasActions = phase.actions && phase.actions.length > 0;
            
            if (hasActions && currentActionIndex < phase.actions.length - 1) {
                nextBtn.textContent = 'Action suivante';
            } else if (currentPhaseIndex < phases.length - 1) {
                nextBtn.textContent = 'Phase suivante';
            } else {
                nextBtn.textContent = 'Fin';
            }
            
            // Afficher le bouton hurlement uniquement pour la phase des Loups-Garous
            const wolfHowlBtn = document.getElementById('wolfHowlBtn');
            if (wolfHowlBtn) {
                if (phase && phase.id === 'loups') {
                    wolfHowlBtn.style.display = 'block';
                } else {
                    wolfHowlBtn.style.display = 'none';
                }
            }
        }

        // Mettre √† jour les boutons de phases
        function updatePhaseButtons() {
            const buttons = phaseSelector.querySelectorAll('.phase-btn');
            buttons.forEach((btn, index) => {
                if (index === currentPhaseIndex) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }

        // Aller √† une phase sp√©cifique
        function goToPhase(index) {
            if (index >= 0 && index < phases.length) {
                currentPhaseIndex = index;
                currentActionIndex = 0;
                updateDisplay();
            }
        }

        // Phase suivante
        function nextPhase() {
            const phase = phases[currentPhaseIndex];
            const hasActions = phase.actions && phase.actions.length > 0;
            
            if (hasActions && currentActionIndex < phase.actions.length - 1) {
                // Action suivante dans la phase - juste mettre √† jour la ligne active
                currentActionIndex++;
                // Mettre √† jour uniquement les classes CSS des actions, sans recalculer quoi que ce soit
                // Utiliser requestAnimationFrame pour √©viter les recalculs de layout
                requestAnimationFrame(() => {
                    updateActionHighlight();
                });
                // Mettre √† jour le texte du bouton de mani√®re synchrone pour √©viter les effets visuels
                updateButtons();
            } else if (currentPhaseIndex < phases.length - 1) {
                // Phase suivante - changer de phase compl√®tement
                currentPhaseIndex++;
                currentActionIndex = 0;
                updateDisplay();
            } else if (phase.id === 'fin') {
                // Si on est √† la fin de partie et qu'on continue, boucler vers une nouvelle nuit
                // Trouver la premi√®re phase de nuit normale (nuit_suivante)
                const firstNuitIndex = phases.findIndex(p => p.id === 'nuit_suivante');
                if (firstNuitIndex !== -1) {
                    currentPhaseIndex = firstNuitIndex;
                    currentActionIndex = 0;
                    updateDisplay();
                }
            }
        }

        // √âv√©nements
        startBtn.addEventListener('click', () => {
            currentPhaseIndex = 1;
            currentActionIndex = 0;
            updateDisplay();
        });

        nextBtn.addEventListener('click', nextPhase);

        // Navigation clavier
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') {
                e.preventDefault();
                nextPhase();
            }
        });

        // Initialisation au chargement
        init();
    </script>
</body>
</html>

